/* ArithmeticExpression.jj */

options {
  // Generate the parser in a single class
  static = false;
}

// Define the parser class
PARSER_BEGIN(MindGRAF_Parser)
package edu.guc.mind_graf.parser;
import edu.guc.mind_graf.context.ContextController;
import edu.guc.mind_graf.components.CustomMethod;
import edu.guc.mind_graf.network.NetworkController;
import edu.guc.mind_graf.components.Substitutions;
import edu.guc.mind_graf.paths.IrreflexiveRestrictPath;
import edu.guc.mind_graf.paths.DomainRestrictPath;
import edu.guc.mind_graf.paths.BUnitPath;
import edu.guc.mind_graf.paths.BangPath;
import edu.guc.mind_graf.paths.OrPath;
import edu.guc.mind_graf.paths.EmptyPath;
import edu.guc.mind_graf.paths.FUnitPath;
import edu.guc.mind_graf.paths.AndPath;
import java.util.LinkedList;


import java.util.ArrayList;
import java.util.HashMap;
import java.io.StringReader;
import edu.guc.mind_graf.paths.KPlusPath;
import edu.guc.mind_graf.paths.KStarPath;
import edu.guc.mind_graf.nodes.ActNode;
import edu.guc.mind_graf.set.NodeSet;
import edu.guc.mind_graf.set.Set;
import java.util.HashSet;
import java.util.HashSet;
import java.util.Hashtable;
import edu.guc.mind_graf.paths.ConversePath;
import edu.guc.mind_graf.paths.ComposePath;
import edu.guc.mind_graf.paths.Path;
import java.util.Map.Entry;
import edu.guc.mind_graf.cables.DownCable;
import edu.guc.mind_graf.cables.DownCableSet;
import edu.guc.mind_graf.caseFrames.Adjustability;
import edu.guc.mind_graf.context.Context;
import java.util.Collection;
import java.util.Collections;
import edu.guc.mind_graf.exceptions.NoSuchTypeException;
import edu.guc.mind_graf.mgip.reports.KnownInstance;
import edu.guc.mind_graf.exceptions.DirectCycleException;
import edu.guc.mind_graf.exceptions.NoPlansExistForTheActException;
import edu.guc.mind_graf.network.Network;
import edu.guc.mind_graf.nodes.Node;
import edu.guc.mind_graf.paths.RangeRestrictPath;
import edu.guc.mind_graf.relations.Relation;
import edu.guc.mind_graf.nodes.PropositionNode;

public class MindGRAF_Parser {
      private static ContextController controller = new ContextController();
      private static int  mode = 1;
      static boolean uvbrEnabled;
      private Network network =new Network();
    
      //setting the attitudes 
      private static int attitudeNumber = 1;
      private static HashMap<String, Integer> initialAttitudes = new HashMap<String, Integer>();

     //setting the consistent attitudes
      private static ArrayList<ArrayList<Integer>> consisAttitudeLists = new ArrayList<ArrayList<Integer>>();
      private  static ArrayList<Integer> consisAttitudeList = new ArrayList<Integer>();
      private static int currConsisAttitude;
      //setting closed under conjunction Attitudes
      private static ArrayList<Integer> finalConjList;

      //setting closed under consequence Attitudes
      private  static ArrayList<Integer> finalConseqList;

       //setting telescopable Attitudes
        private  static ArrayList<Integer> finalTelList;

      //automaticHandling
      private static boolean automaticHandling;
      
      //cacheEnabled
      private static boolean cacheEnabled;

      //mergeFN
      private static int mergeFN;
      //creation of nodes
        //private static ArrayList<Node> molecNodes = new ArrayList<Node>();
        private static HashMap<String, DownCable> allDCB = new HashMap<String, DownCable>();

      //case frames
       private static HashMap<String, ArrayList<String>> caseFrames = new HashMap<String, ArrayList<String>>();

      // semantic type
      private static ArrayList<CustomMethod> customMethods = new ArrayList<CustomMethod>();


      //forall
      private static HashMap<String,Node> varNodesForall = new HashMap<String,Node>();

      // wffs
      private static HashMap<Integer, ArrayList<String>> wffs = new HashMap<Integer, ArrayList<String>>();
      private static Integer wffCount = 1;

      //default attitude
      private static Integer defaultAttitude = 0;

      //levels
      private static boolean firstExpression = true;
      private static boolean isGrading = true;
      private static int levelsCount = 0;

    public static <K, V> HashMap<V, ArrayList<K>> groupByValue(HashMap<K, V> originalMap) {
    HashMap<V, ArrayList<K>> groupedMap = new HashMap<>();
    for (HashMap.Entry<K, V> entry : originalMap.entrySet()) {
        V value = entry.getValue();
        ArrayList<K> keys = groupedMap.get(value);
        if (keys == null) {
            keys = new ArrayList<>();
            groupedMap.put(value, keys);
        }
        keys.add(entry.getKey());
    }
    return groupedMap;
}

  public static void removeFromContext(String CName, String attitude, boolean a, boolean c, PropositionNode propNode) {
    try {
      if (c && a) {
        if (!controller.getContextSet().getSet().containsKey(CName)) {
          CLI.print("No such Context.");
          return;
        }
        if (!controller.getAttitudes().getSet().containsKey(attitude)) {
          CLI.print("No such Attitude.");
          return;
        }
        controller.removeHypothesisFromContext(CName, levelsCount, controller.getAttitudeNumber(attitude),
            propNode.getId());
        CLI.print("Hypothesis Removed.");

        return;
      }
      if (c) {
        if (!controller.getContextSet().getSet().containsKey(CName)) {
          CLI.print("No such Context.");
          return;
        }
        controller.removeHypothesisFromContext(CName, levelsCount, defaultAttitude, propNode.getId());
        CLI.print("Hypothesis Removed.");

        return;
      }
      if (a) {
        if (!controller.getAttitudes().getSet().containsKey(attitude)) {
          CLI.print("No such Attitude.");
          return;
        }
        try {
          controller.removeHypothesisFromContext(controller.getCurrContextName(), levelsCount,
              controller.getAttitudeNumber(attitude), propNode.getId());
          CLI.print("Hypothesis Removed.");

        } catch (NullPointerException e) {
          CLI.print("Set Current Context First.");
          return;
        }
      }
      try {
        controller.removeHypothesisFromContext(controller.getCurrContextName(), levelsCount, defaultAttitude,
            propNode.getId());
        CLI.print("Hypothesis Removed.");

      } catch (NullPointerException e) {
        CLI.print("Set Current Context First.");
        return;
      }
    } catch (Exception e) {
      // TODO Auto-generated catch block
      e.printStackTrace();
    }
  }
  public static void addToContext(String CName, String attitude, boolean a, boolean c, PropositionNode propNode){
    try {
      if (c && a) {
        if (!controller.getContextSet().getSet().containsKey(CName)) {
          CLI.print("No such Context.");
          return;
        }
        if (!controller.getAttitudes().getSet().containsKey(attitude)) {
          CLI.print("No such Attitude.");
          return;
        }
        controller.addHypothesisToContext(CName, levelsCount, controller.getAttitudeNumber(attitude), propNode);

        return;

      }
      if (c) {
        if (!controller.getContextSet().getSet().containsKey(CName)) {
          CLI.print("No such Context.");
          return;
        }
        controller.addHypothesisToContext(CName, levelsCount, defaultAttitude, propNode);

        return;
      }
      if (a) {
        if (!controller.getAttitudes().getSet().containsKey(attitude)) {
          CLI.print("No such Attitude.");
          return;
        }
        try {
          controller.addHypothesisToContext(controller.getCurrContextName(), levelsCount,
              controller.getAttitudeNumber(attitude), propNode);
 
        } catch (NullPointerException e) {
          CLI.print("Set Current Context First.");
          return;
        }
      }
      try {
        controller.addHypothesisToContext(controller.getCurrContextName(), levelsCount, defaultAttitude, propNode);

      } catch (NullPointerException e) {
        CLI.print("Set Current Context First.");
        return;
      }
    } catch (Exception e) {
      // TODO Auto-generated catch block
      e.printStackTrace();
    }
  }


        @SuppressWarnings("static-access")
        public static void removeDuplicates(ArrayList<String> list) {
        HashSet<String> set = new HashSet<>();
        for (int i = 0; i < list.size(); i++) {
            String str = list.get(i);
            if (!set.add(str)) { // If adding the string returns false, it's a duplicate
                list.remove(i); // Remove the duplicate string
                i--; // Decrement i to adjust for the removed element
            }
        }
    }
      public static void bInference(PropositionNode propNode, boolean c, boolean a, String CName, String attitude) {
    try {
      if (c && a) {
        if (!controller.getContextSet().getSet().containsKey(CName)) {
          CLI.print("No such Context.");
          {
            if ("" != null)
              return;
          }
        }
        if (!controller.getAttitudes().getSet().containsKey(attitude)) {
          CLI.print("No such Attitude.");
          return;
        }
        propNode.deduce(CName, controller.getAttitudeNumber(attitude));
        return;
      }
      if (c) {
        if (!controller.getContextSet().getSet().containsKey(CName)) {
          CLI.print("No such Context.");
          return;
        }
        propNode.deduce(CName, defaultAttitude);

        return;

      }
      if (a) {
        if (!controller.getAttitudes().getSet().containsKey(attitude)) {
          CLI.print("No such Attitude.");

          return;

        }
        try {
          propNode.deduce(controller.getCurrContextName(), controller.getAttitudeNumber(attitude));
        } catch (NullPointerException e) {
          CLI.print("Set Current Context First.");
          return;
        }
      }
      try {
        propNode.deduce(controller.getCurrContextName(), defaultAttitude);
      } catch (NullPointerException e) {
        CLI.print("Set Current Context First.");
        return;
      }
    } catch (NoSuchTypeException | NoPlansExistForTheActException | DirectCycleException e) {
      // TODO Auto-generated catch block
      e.printStackTrace();
    }
  }

  public static int indexOfList(ArrayList<ArrayList<String>> listOfLists, ArrayList<String> listToAdd) {
    // Iterate over the listOfLists and compare each inner list with listToAdd
    for (int i = 0; i < listOfLists.size(); i++) {
      ArrayList<String> currentList = listOfLists.get(i);
      if (areListsEqual(currentList, listToAdd)) {
        return i; // If found, return the index
      }
    }
    return -1; // If not found, return -1
  }

  private static boolean areListsEqual(ArrayList<String> list1, ArrayList<String> list2) {
    // Check if the lists have the same size
    if (list1.size() != list2.size()) {
      return false;
    }
    // Check if the elements in list1 exist in list2
    for (String element : list1) {
      if (!list2.contains(element)) {
        return false;
      }
    }
    // Check if the elements in list2 exist in list1
    for (String element : list2) {
      if (!list1.contains(element)) {
        return false;
      }
    }
    // If all elements are found in both lists, they are equal
    return true;
  }
  public Node compareMolecularNode(DownCableSet dcs) {
    Node returnNode = null;
    for (Node nn : network.getNodes().values()) {
      DownCableSet downc = nn.getDownCableSet();
      if (downc != null) {
        String key = downc.getMolecularSetKey();
        if (key.equals(dcs.getMolecularSetKey())) {
          returnNode = nn;
          Collection<DownCable> dcCollection = downc.getValues();
          for (DownCable d : dcCollection) {
            String relName = d.getRelation().getName();
            ArrayList<String> firstNs = d.getNodeSet().getNames();
            ArrayList<String> ns = dcs.get(relName).getNodeSet().getNames();
            if (!firstNs.equals(ns))
              return null;
          }
          break;
        }
      }
    }
    return returnNode;

  }
    public static void fInference(PropositionNode propNode, boolean c, boolean a, String CName, String attitude) {
    try {
      if (c && a) {
        if (!controller.getContextSet().getSet().containsKey(CName)) {
          CLI.print("No such Context.");
          {
            if ("" != null)
              return;
          }
        }
        if (!controller.getAttitudes().getSet().containsKey(attitude)) {
          CLI.print("No such Attitude.");
              return;
        }
        propNode.add(CName, controller.getAttitudeNumber(attitude));
            return;
      }
      if (c) {
        if (!controller.getContextSet().getSet().containsKey(CName)) {
          CLI.print("No such Context.");
              return;
        }
        propNode.add(CName, defaultAttitude);

            return;
        
      }
      if (a) {
        if (!controller.getAttitudes().getSet().containsKey(attitude)) {
          CLI.print("No such Attitude.");

              return;
          
        }
        try {
          propNode.add(controller.getCurrContextName(), controller.getAttitudeNumber(attitude));
        } catch (NullPointerException e) {
          CLI.print("Set Current Context First.");
              return;
        }
      }
      try {
        propNode.add(controller.getCurrContextName(), defaultAttitude);
      } catch (NullPointerException e) {
        CLI.print("Set Current Context First.");
            return;
      }
    } catch (NoSuchTypeException | NoPlansExistForTheActException | DirectCycleException e) {
      // TODO Auto-generated catch block
      e.printStackTrace();
    }
  }
    public static Integer isSupported(PropositionNode propNode, boolean c, boolean a, String CName, String attitude) {
    try {
      if (c && a) {
        if (!controller.getContextSet().getSet().containsKey(CName)) {
          CLI.print("No such Context.");
          return null;

        }
        if (!controller.getAttitudes().getSet().containsKey(attitude)) {
          CLI.print("No such Attitude.");
          return null;
        }

        return propNode.supported(CName, controller.getAttitudeNumber(attitude), levelsCount) ? 1 : 0;
      }
      if (c) {
        if (!controller.getContextSet().getSet().containsKey(CName)) {
          CLI.print("No such Context.");
          return null;
        }
        return propNode.supported(CName, defaultAttitude, levelsCount) ? 1 : 0;

      }
      if (a) {
        if (!controller.getAttitudes().getSet().containsKey(attitude)) {
          CLI.print("No such Attitude.");

          return null;

        }
        try {
          return propNode.supported(controller.getCurrContextName(), controller.getAttitudeNumber(attitude),
              levelsCount) ? 1 : 0;
        } catch (NullPointerException e) {
          CLI.print("Set Current Context First.");
          return null;
        }
      }
      try {
        return propNode.supported(controller.getCurrContextName(), defaultAttitude,
            levelsCount) ? 1 : 0;
      } catch (NullPointerException e) {
        CLI.print("Set Current Context First.");
        return null;
      }
    } catch (Exception e) {
      // TODO Auto-generated catch block
      e.printStackTrace();
      return null;
    }
  }

  public static void main(String[] args) throws ParseException {
    // Instantiate the parser
    MindGRAF_Parser parser = new MindGRAF_Parser(System.in);
   /* try {
      // Start parsing
      parser.Start();

      System.out.println("Parsing successful!");
    } catch (ParseException e) {
      // Handle parsing errors
      System.err.println("Parsing failed: " + e.getMessage());
    }*/
  }
}

 
PARSER_END(MindGRAF_Parser)

// Define tokens
SKIP:  {"\t" | "\n" | "\r"|" "}
TOKEN :
{ 
  <NUMBER: (["0"-"9"])+>
| <currContext: "get-curr-context">
| <GetAttitudeNames: "get-attitudes">
| <MODE1: "set-mode-1">
| <MODE2: "set-mode-2">
| <MODE3: "set-mode-3">
| <N:"N"|"n">
| < #IDENTIFIER: <LETTER> (<LETTER>|<DIGIT>)* >
| < #LETTER: ["_","a"-"z","A"-"Z"] >
| < #DIGIT: ["0"-"9"] >
| <ANDOR_THRESH: (("andor"|"thresh")"(")>
| <ADJUST: ("expand"| "reduce"|"none")>
| <RELATION_TYPE: ("expand"| "reduce"|"none")>
| <WHENDO_DOIF: (("whendo"|"doif")"{")>
| <QUANTIFIER: "forall(">
| <ENTAILMENT:("&=>"|"v=>"|(<NUMBER>"=>"))>
| <VARIABLE: "?">
| <WFF_NAME: "WFF"(<DIGIT>)+>

| <STRING: (["a"-"z", "A"-"Z"])+ (["a"-"z", "A"-"Z", "0"-"9", "_"])*>
| <PREDICATE_NAME_BRACKET: ((["a"-"z", "A"-"Z"])+ (["a"-"z", "A"-"Z", "0"-"9", "_"])*"(")>









}

// Define the grammar


Node Expression() throws ParseException : {
  Node result = null;
}
{(
     result = Predicate()| result = AndOrThreshExpression(false) | result = OrAndEntailment(false) | result = forall()
    | result = WhenIfDo() | result = gradedProp() | result = negatedProp()
)
    {
      return result;
    }
}

Node andOrThreshEnt() throws ParseException :
{
  Node arg;
}
{
 ( (arg = AndOrThreshExpression(true) |  arg = OrAndEntailment(true)) )

  {
    return arg;
  }
  
}
Node negatedAndOrThreshEnt() throws ParseException :
{
Node node = null;
}
{
"~"node = andOrThreshEnt()
  {
      Node negatedNode = null;
      try {
         negatedNode = node.createNegation(node);
      } catch (NoSuchTypeException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
      }
    return negatedNode;
  } 
}


Node gradedAndOrThreshEnt() : 
{
  Node node = null;
  String gradeValue = null;
}
{ 
  "g{"node = andOrThreshEnt()","gradeValue = <NUMBER>.image"}"
  {
    gradeValue = gradeValue.trim();
    // Relations
    Relation grade = network.getRelations().get("grade");
    Relation prop = network.getRelations().get("prop");

    // nodes
    Node gradeNode = null;
    Node molecNode = null;
    try {
      gradeNode = network.createNode(gradeValue, "individualnode");
      // cables
      DownCable gradeDC = new DownCable(grade, new NodeSet(gradeNode));
      DownCable propDC = new DownCable(prop, new NodeSet(node));
      DownCableSet alldcs = new DownCableSet(gradeDC, propDC);
      Node shouldCreate = compareMolecularNode(alldcs);
      if (shouldCreate == null)
        molecNode = network.createNode("propositionnode", alldcs);
      else
        molecNode = shouldCreate;
    } catch (NoSuchTypeException e) {
      // TODO Auto-generated catch block
      e.printStackTrace();
    }
    return molecNode;
  }
}



Node ForallExpressionList() throws ParseException :
{
  Node arg;
}
{
 arg = andOrThreshEnt() | arg = gradedAndOrThreshEnt() | arg = negatedAndOrThreshEnt()

  {
    return arg;
  }
  
}

Node forall() throws ParseException :
{
  firstExpression = false;
  Node arg = null;
  ArrayList<Node> varNodes = new ArrayList<Node>();
  isGrading = false;
}
{
  <QUANTIFIER>varNodes  = variableNodes(){
     HashMap<String, Node> nodeSet = new HashMap<String, Node>();
    for (Node n : varNodes)
      nodeSet.put(n.getName(), n);

    varNodesForall = nodeSet;
  }")""("arg = ForallExpressionList()")"
  {
   

    return arg;
  }
}

ArrayList<Node> variableNodes() throws ParseException :
{
  Node varNode = null;
  String var = null;
  ArrayList<Node>varNodes = new ArrayList<Node>();
}
{
  (
  var = <STRING>.image
  {
    String s = var.trim().toLowerCase();
    try {
      varNodes.add(network.createVariableNode(s, "propositionnode"));
    } catch (NoSuchTypeException e) {
      // TODO Auto-generated catch block
      e.printStackTrace();
    }
  }
  ) (","var = <STRING>.image{
    String ss = var.trim().toLowerCase();
    try {
      varNodes.add(network.createVariableNode(ss, "propositionnode"));
    } catch (NoSuchTypeException e) {
      // TODO Auto-generated catch block
      e.printStackTrace();
    }
  })*
  {
    return varNodes;
  }
  
}


Node WhenIfDo() throws ParseException : 
{
  Node prop = null;
  Node actNode = null;
  String attitude;
  String ruleType;
  firstExpression = false;
  isGrading = false;
} 
{
   ruleType = <WHENDO_DOIF>.image 
   prop = Expression()","
   attitude = <STRING>.image"}"
   "=>""{"actNode = Act()"}"
   {
    ruleType = ruleType.trim().toLowerCase();
    ruleType = ruleType.substring(0, ruleType.length() - 1);
    attitude = attitude.trim().toLowerCase();
    Integer attNum = controller.getAttitudeNumber(attitude);
    if (attNum == null)
      throw new ParseException("No such attitude.");

    Relation doRel = network.getRelations().get("do");
    DownCable doDC = new DownCable(doRel, new NodeSet(actNode));
    if (ruleType.equals("whendo")) {
      // creating when do relations
      Relation whenRel = network.createRelation(attNum + "-when", "propositionnode", Adjustability.NONE, 0);
      // downcable
      DownCable whenDC = new DownCable(whenRel, new NodeSet(prop));

      DownCableSet whenDoDC = new DownCableSet(whenDC, doDC);
      // creating whenDo Rule Node
      Node shouldCreate = compareMolecularNode(whenDoDC);
      Node whenDoNode = null;
      try {
        if (shouldCreate == null)
          whenDoNode = network.createNode("propositionnode", whenDoDC);
        else
          whenDoNode = shouldCreate;
      } catch (NoSuchTypeException e) {
        // TODO: handle exception
      }
      return whenDoNode;

    } else {
      // creating do if relations
      Relation ifRel = network.createRelation(attNum + "-if", "propositionnode", Adjustability.NONE, 0);

      // downcable
      DownCable ifDC = new DownCable(ifRel, new NodeSet(prop));

      DownCableSet ifDoDC = new DownCableSet(ifDC, doDC);
      // creating whenDo Rule Node
      Node shouldCreate = compareMolecularNode(ifDoDC);
      Node ifDoNode = null;
      try {
        if (shouldCreate == null)
          ifDoNode = network.createNode("propositionnode", ifDoDC);
        else
          ifDoNode = shouldCreate;
      } catch (NoSuchTypeException e) {
        // TODO: handle exception
      }
      return ifDoNode;

    }
   }
}

ActNode Act() throws ParseException :
{
    Node act = null;
}
{
    (
        act = SNSequence() |
        act = Attitude() |
        act = Achieve() |
        act = DoOne() |
        act = DoAll() |
        act = GuardedAct() |
        act = SNIF() |
        act = SNIterate()
    )
    {
        return (ActNode) act;
    }
    {
        throw new ParseException("No valid action found.");
    }
}



Node SNSequence() throws ParseException:
{
  Node actNodeOne = null;
  Node actNodeTwo = null;

}
{
  "snsequence{"actNodeOne = Act()","actNodeTwo = Act()"}"
  {

    // relations
    Relation obj1 = network.createRelation("obj1", "actnode", Adjustability.NONE, 1);
    Relation obj2 = network.createRelation("obj2", "actnode", Adjustability.NONE, 1);
    Relation action = network.getRelations().get("action");
    Node snSeqIndividual = null;
    Node snsequenceNode = null;
    try {
      // individual node
      snSeqIndividual = network.createNode("snsequence", "individualnode");
      // Cables
      DownCable actionDC = new DownCable(action, new NodeSet(snSeqIndividual));
      DownCable obj1DC = new DownCable(obj1, new NodeSet(actNodeOne));
      DownCable obj2DC = new DownCable(obj2, new NodeSet(actNodeTwo));
      DownCableSet alldcs = new DownCableSet(actionDC, obj1DC, obj2DC);
      // snsequence act node creation
      Node shouldCreate = compareMolecularNode(alldcs);
      if(shouldCreate == null)
        snsequenceNode = network.createNode("actnode", new DownCableSet(actionDC, obj1DC, obj2DC));
      else
        snsequenceNode = shouldCreate;
    } catch (NoSuchTypeException e) {
      // TODO Auto-generated catch block
      e.printStackTrace();
    }
    return snsequenceNode;

  }
}

Relation Relation() throws ParseException:
{
String name = null;
String type = null;
String adjust = null;
String limit ;
}
{
  "rel{"name = <STRING>.image"," type = <STRING>.image","adjust = <ADJUST>.image","limit = <NUMBER>.image"}"
  {

    name = name.trim().toLowerCase();
    type = type.trim().toLowerCase();
    adjust = adjust.trim();
    Relation relation = Network.createRelation(name, type, adjust.equals("expand") ? Adjustability.EXPAND
        : adjust.equals("reduce") ? Adjustability.REDUCE : Adjustability.NONE, Integer.parseInt(limit));
    return relation;
  }
}



Path FUnit() throws ParseException :
{
  Relation relation = null;
  String relationName = null;
}
{
 "f-unit("(relation =Relation() | relationName = <STRING>.image)")"
 {
  if(relationName ==  null)
{   
  FUnitPath fUnit = new FUnitPath(relation);
  return fUnit;
}
  relationName = relationName.trim().toLowerCase();
  if(!Network.getRelations().containsKey(relationName))
    throw new ParseException("No Such Relation.");
  
  relation = Network.getRelations().get(relationName);
  FUnitPath fUnit = new FUnitPath(relation);
  return fUnit;

 }

 }




Path BUnit() throws ParseException :
{
  Relation relation = null;
  String relationName = null;}
{
 "b-unit(" (relation =Relation() | relationName = <STRING>.image)")"
 {
  if(relationName ==  null)
{   
  BUnitPath bUnit = new BUnitPath(relation);
  return bUnit;
}
  relationName = relationName.trim().toLowerCase();
  if(!Network.getRelations().containsKey(relationName))
    throw new ParseException("No Such Relation.");
  
  relation = Network.getRelations().get(relationName);
  BUnitPath bUnit = new BUnitPath(relation);
  return bUnit;

 }
}

Path ComposePath() throws ParseException :
{
  Path onePath = null;
  LinkedList<Path> allPaths = new LinkedList<Path>();

}
{
 "compose-path("onePath = Path(){allPaths.add(onePath);}(","onePath = Path(){allPaths.add(onePath);})*")"
 {
    ComposePath composePath = new ComposePath(allPaths);
    return composePath;
 }
}

Path ConversePath() throws ParseException :
{
  Path path= null;
}
{
 "converse-path("path = Path()")"
 {
  ConversePath conversePath = new ConversePath(path);
  return conversePath; }
}

Path KStar() throws ParseException :
{
  Path path = null;
}
{
 "k-start("path = Path()")"
 {
    KStarPath kstar = new KStarPath(path);
    return kstar;
 }
}

Path KPlus() throws ParseException :
{
  Path path = null;
}
{
 "k-plus("path = Path()")"
 {
    KPlusPath kplus = new KPlusPath(path);
    return kplus;
 }
}


Path OrPath() throws ParseException :
{
 Path onePath = null;
 LinkedList<Path> allPaths = new LinkedList<Path>(); 
}
{
 "or-path("onePath = Path(){allPaths.add(onePath);}(","onePath = Path(){allPaths.add(onePath);})*")"
 {
    OrPath orPath = new OrPath(allPaths);
    return orPath; }
}



Path AndPath() throws ParseException :
{
 Path onePath = null;
 LinkedList<Path> allPaths = new LinkedList<Path>(); 
}
{
 "and-path("onePath = Path(){allPaths.add(onePath);}(","onePath = Path(){allPaths.add(onePath);})*")"
 {
  AndPath andPath = new AndPath(allPaths);
  return andPath;
 }
}

Path IrreflexiveRestrictPath() throws ParseException :
{
  Path path = null;
}
{
 "irreflexive-restrict("path = Path()")"
 {
    IrreflexiveRestrictPath irrefPath = new IrreflexiveRestrictPath(path);
    return irrefPath;
 }
}

Path DomainRestrictPath() throws ParseException :
{
  Path p1 = null;
  Path p2 = null;
  Node node = null;
}
{
 "domain-restrict("Path()","Path()","Expression()")"
 {
    DomainRestrictPath domainPath = new DomainRestrictPath(p1, p2, node);
    return domainPath; 
 }

}

Path RangeRestrictPath() throws ParseException :
{
  Path p1 = null;
  Path p2 = null;
  Node node = null;
}
{
 "range-restrict("Path()","Path()","Expression()")"
 {
    RangeRestrictPath rangePath = new RangeRestrictPath(p1, p2, node);
    return rangePath; 
 }

}

Path BangPath() throws ParseException : 
{}
{
  "bang-path"
  {
    BangPath bangPath = new BangPath();
    return bangPath;  
  }
}

Path EmptyPath() throws ParseException : 
{}
{
  "empty-path"
  {
    EmptyPath emptyPath = new EmptyPath();
    return emptyPath;
  }
}

Path Path() throws ParseException :
{
  Path path = null;
 
}
{
  path = FUnit() 
   {
    return path;
  }
| path = BUnit()
 {
    return path;
  }
| path = OrPath()
 {
    return path;
  }
| path = AndPath()
 {
    return path;
  }
| path = BangPath()
 {
    return path;
  }
| path = EmptyPath()
 {
    return path;
  }
| path = KPlus()
 {
    return path;
  }
| path = KStar()
 {
    return path;
  }
| path = ComposePath()
 {
    return path;
  }
| path = RangeRestrictPath()
 {
    return path;
  }
| path = DomainRestrictPath()
 {
    return path;
  }
| path = IrreflexiveRestrictPath()
 {
    return path;
  }
| path = ConversePath()
  
  {
    return path;
  }

}


void definePath() throws ParseException:
{
  Path path = null;
  Relation relation = null;
  String relationName = null;
}
{
  "define-path" (relation = Relation() | relationName = <STRING>.image) path = Path()
{ 
   if(relationName == null)
{
    relation.setPath(path);
    CLI.print("Path '" + relation.getPath().toString()+"' is Defined for relation " + relation.getName()+"." );

    return;
}
  relationName = relationName.trim().toLowerCase();
  if(!Network.getRelations().containsKey(relationName))
    throw new ParseException("No Such Relation.");
  
  relation = Network.getRelations().get(relationName);
  relation.setPath(path);
  CLI.print("Path '" + relation.getPath().toString()+"' is Defined for relation " + "'"+relation.getName()+"'"+"." );

    

}
}

Node Attitude() throws ParseException : 
{
  Node prop = null;
}
{
  "attitude{"prop = Expression()"}"
  {

    // relations
    Relation action = network.getRelations().get("action");
    Relation obj = network.getRelations().get("obj");

    // attitude indiv node
    Node attitudeIndividual = null;
    Node attitudeActNode = null;
    try {
      attitudeIndividual = network.createNode("attitude", "individualnode");

      // cables
      DownCable objDC = new DownCable(obj, new NodeSet(prop));
      DownCable actionDC = new DownCable(action, new NodeSet(attitudeIndividual));
      DownCableSet alldcs = new DownCableSet(objDC, actionDC);
      // attitude act node
      Node shouldCreate = compareMolecularNode(alldcs);
      if(shouldCreate == null)
        attitudeActNode = network.createNode("actnode", new DownCableSet(objDC, actionDC));
      else 
        attitudeActNode = shouldCreate;

    } catch (NoSuchTypeException e) {
      // TODO Auto-generated catch block
      e.printStackTrace();
    }
    return attitudeActNode;
 
  }
}

Node Achieve() throws ParseException : 
{
  Node prop = null;
}
{
  "achieve{"prop = Expression()"}"
  {

    // relations
    Relation action = network.getRelations().get("action");
    Relation obj = network.getRelations().get("obj");

    // believe indiv node
    Node achieveIndividual = null;
    Node achieveActNode = null;
    try {
      achieveIndividual = network.createNode("achieve", "individualnode");

      // cables
      DownCable objDC = new DownCable(obj, new NodeSet(prop));
      DownCable actionDC = new DownCable(action, new NodeSet(achieveIndividual));
      DownCableSet alldcs = new DownCableSet(objDC, actionDC);
      // achieve act node
      Node shouldCreate = compareMolecularNode(alldcs);
      if(shouldCreate == null)
        achieveActNode = network.createNode("actnode", new DownCableSet(objDC, actionDC));
      else 
        achieveActNode = shouldCreate;

    } catch (NoSuchTypeException e) {
      // TODO Auto-generated catch block
      e.printStackTrace();
    }
    return achieveActNode;
 
  }
}

Node DoOne() throws ParseException :
{
  HashMap<String, Node> hashedNodes = new HashMap<String, Node>();
  Node oneAct;
}
{
  "doone{"oneAct = Act(){hashedNodes.put(oneAct.getName(),oneAct);}
  (","oneAct = Act() {hashedNodes.put(oneAct.getName(),oneAct);})*"}"
  {
    
    // relations
    Relation action = network.getRelations().get("action");
    Relation obj = network.getRelations().get("obj");

    // dooneIndividual
    Node doOneIndiv = null;
    Node doOneActNode = null;
    try {
      doOneIndiv = network.createNode("doone", "individualnode");
      //cables
      DownCable actionDC = new DownCable(action, new NodeSet(doOneIndiv));
      DownCable objDC = new DownCable(obj, new NodeSet(hashedNodes));
      DownCableSet allCables = new DownCableSet(actionDC, objDC);
      Node shouldCreate = compareMolecularNode(allCables);
      if(shouldCreate == null)
        doOneActNode = network.createNode("actnode", allCables);
      else
        doOneActNode = shouldCreate;
    } catch (NoSuchTypeException e) {
      // TODO Auto-generated catch block
      e.printStackTrace();
    }
    return doOneActNode;
  }
}


Node DoAll() throws ParseException :
{
  HashMap<String, Node> hashedNodes = new HashMap<String, Node>();
  Node oneAct;
}
{
  "do-one{"oneAct = Act(){hashedNodes.put(oneAct.getName(),oneAct);}
  (","oneAct = Act() {hashedNodes.put(oneAct.getName(),oneAct);})*"}"
  {
    
    // relations
    Relation action = network.getRelations().get("action");
    Relation obj = network.getRelations().get("obj");

    // doAllIndividual
    Node doAllIndiv = null;
    Node doAllActNode = null;
    try {
      doAllIndiv = network.createNode("doall", "individualnode");
      //cables
      DownCable actionDC = new DownCable(action, new NodeSet(doAllIndiv));
      DownCable objDC = new DownCable(obj, new NodeSet(hashedNodes));
      DownCableSet allCables = new DownCableSet(actionDC, objDC);
      Node shouldCreate = compareMolecularNode(allCables);
      if(shouldCreate == null)
        doAllActNode = network.createNode("actnode", allCables);
      else
        doAllActNode = shouldCreate;
    } catch (NoSuchTypeException e) {
      // TODO Auto-generated catch block
      e.printStackTrace();
    }
    return doAllActNode;
  }
}

Node GuardedAct() throws ParseException :
{
  Node actNode = null;
  Node prop = null;
}
{
  "guard{"actNode = Act()","prop = Expression()"}"
  {
        // Relations
    Relation actRel = network.createRelation("act", "actnode", Adjustability.NONE, 1);
    Relation guardRel = network.createRelation("guard", "propositionnode", Adjustability.NONE, 1);

    // cables
    DownCable actDC = new DownCable(actRel, new NodeSet(actNode));
    DownCable guardDC = new DownCable(guardRel, new NodeSet(prop));

    DownCableSet allcables = new DownCableSet(actDC, guardDC);
    // creating guarded actnode
    Node guardedActNode = null;
    Node shouldCreate = compareMolecularNode(allcables);
    try {
      if (shouldCreate == null)
        guardedActNode = network.createNode("actnode", allcables);
      else
        guardedActNode = shouldCreate;
    } catch (NoSuchTypeException e) {
      // TODO Auto-generated catch block
      e.printStackTrace();
    }
    return guardedActNode;
  }
}

Node SNIF() throws ParseException : 
{
  Node oneGuardAct = null;
  HashMap<String,Node> allGuardActs = new HashMap<String, Node>();
}
{
  "snif{"oneGuardAct = GuardedAct(){allGuardActs.put(oneGuardAct.getName(),oneGuardAct);}(","oneGuardAct = GuardedAct(){allGuardActs.put(oneGuardAct.getName(),oneGuardAct);})*"}"
  {
    // relations
    Relation action = network.getRelations().get("action");
    Relation obj = network.getRelations().get("obj");

    // snif indiv node
    Node snifIndividual = null;
    Node snifActNode = null;
    try {
      snifIndividual = network.createNode("snif", "individualnode");
      //cables
       DownCable actionDC = new DownCable(action, new NodeSet(snifIndividual));
       DownCable objDC = new DownCable(obj, new NodeSet(allGuardActs));
       DownCableSet allCables = new DownCableSet(actionDC, objDC);

       //creating snif act node
       Node shouldCreate = compareMolecularNode(allCables);
       if(shouldCreate == null)
        snifActNode = network.createNode("actnode", allCables);
       else
        snifActNode = shouldCreate;
    } catch (NoSuchTypeException e) {
      // TODO Auto-generated catch block
      e.printStackTrace();
    }
    return snifActNode;  }
}

Node SNIterate() throws ParseException : 
{
  Node oneGuardAct = null;
  HashMap<String,Node> allGuardActs = new HashMap<String, Node>();
}
{
  "sniterate{"oneGuardAct = GuardedAct(){allGuardActs.put(oneGuardAct.getName(),oneGuardAct);}(","oneGuardAct = GuardedAct(){allGuardActs.put(oneGuardAct.getName(),oneGuardAct);})*"}"
  {
    // relations
    Relation action = network.getRelations().get("action");
    Relation obj = network.getRelations().get("obj");

    // sniterate indiv node
    Node sniterateIndividual = null;
    Node sniterateActNode = null;
    try {
      sniterateIndividual = network.createNode("sniterate", "individualnode");
      //cables
       DownCable actionDC = new DownCable(action, new NodeSet(sniterateIndividual));
       DownCable objDC = new DownCable(obj, new NodeSet(allGuardActs));
       DownCableSet allCables = new DownCableSet(actionDC, objDC);

       //creating sniterate act node
       Node shouldCreate = compareMolecularNode(allCables);
       if(shouldCreate == null)
        sniterateActNode = network.createNode("actnode", allCables);
       else
        sniterateActNode = shouldCreate;
    } catch (NoSuchTypeException e) {
      // TODO Auto-generated catch block
      e.printStackTrace();
    }
    return sniterateActNode;  }
}



Node AndOrThreshExpression(boolean quantifier) throws ParseException : {
  Token rule;
  Token i;
  Token j;
  Node node = null;
  ArrayList<Node> nodes = new ArrayList<Node>();
  firstExpression = false;
  isGrading = false;
  }
{
    rule = <ANDOR_THRESH> i = <NUMBER> "," j = <NUMBER> ")" "{" nodes = ExpressionList() "}"
    {    String ruleType = rule.image.trim().toLowerCase();
    ruleType = ruleType.substring(0, ruleType.length() - 1);
    try {
      if (ruleType.equals("andor")) {
        Relation min = network.getRelations().get("min");
        Relation max = network.getRelations().get("max");
        Node minNode = network.createNode(i.image.trim(), "individualnode");
        Node maxNode = network.createNode(j.image.trim(), "individualnode");
        DownCable minCable = new DownCable(min, new NodeSet(minNode));
        DownCable maxCable = new DownCable(max, new NodeSet(maxNode));

        Relation arg = network.getRelations().get("arg");
        HashMap<String, Node> objs = new HashMap<String, Node>();
        for (Node n : nodes)
          objs.put(n.getName(), n);

        NodeSet set = new NodeSet(objs);
        DownCable andorDCB = new DownCable(arg, set);
        HashMap<String, DownCable> sett = new HashMap<String, DownCable>();
        if (quantifier)
         { 
          DownCable quant = new DownCable(network.getRelations().get("forall"), new NodeSet(varNodesForall));
          sett.put(quant.getRelation().getName(), quant);
        }
        sett.put(minCable.getRelation().getName(), minCable);
        sett.put(maxCable.getRelation().getName(), maxCable);
        sett.put(andorDCB.getRelation().getName(), andorDCB);
        
        DownCableSet dcs = new DownCableSet(sett);
        Node shouldCreate = compareMolecularNode(dcs);
        if (shouldCreate == null)
        node = network.createNode("andor", new DownCableSet(sett));
        else
        node = shouldCreate;

      } else {
        Relation threshMax = network.getRelations().get("threshmax");
        Relation thresh = network.getRelations().get("thresh");
        Node threshMaxNode = network.createNode(i.image.trim(), "propositionnode");
        Node threshNode = network.createNode(j.image.trim(), "propositionnode");
        DownCable threshMaxCable = new DownCable(threshMax, new NodeSet(threshMaxNode));
        DownCable threshCable = new DownCable(thresh, new NodeSet(threshNode));

        Relation arg = network.getRelations().get("arg");
        HashMap<String, Node> objs = new HashMap<String, Node>();
        for (Node n : nodes)
          objs.put(n.getName(), n);
        NodeSet set = new NodeSet(objs);
        DownCable threshDCB = new DownCable(arg, set);
        HashMap<String, DownCable> sett = new HashMap<String, DownCable>();
        if (quantifier)
         { 
          DownCable quant = new DownCable(network.getRelations().get("forall"), new NodeSet(varNodesForall));
          sett.put(quant.getRelation().getName(), quant);
        }
        sett.put(threshMaxCable.getRelation().getName(), threshMaxCable);
        sett.put(threshCable.getRelation().getName(), threshCable);
        sett.put(threshDCB.getRelation().getName(), threshDCB);
        DownCableSet dcs = new DownCableSet(sett);
        Node shouldCreate = compareMolecularNode(dcs);
        if (shouldCreate == null)
        node = network.createNode("thresh", new DownCableSet(sett));
        else
        node = shouldCreate;
      }
      
    } catch (NoSuchTypeException e) {
      // TODO Auto-generated catch block
      e.printStackTrace();
    }
    return node;

    }
}

 ArrayList<Node> ExpressionList() throws ParseException : 
{
  ArrayList<Node> nodes = new ArrayList<Node>();
  Node arg;
}
{
  arg = Expression() { nodes.add(arg); }
  (
    "," arg = Expression() { nodes.add(arg); }
  )*
  {
    return nodes;
  }
  
}




Node OrAndEntailment(boolean quantifier) throws ParseException : 
{
firstExpression = false;
ArrayList<Node> cq = new ArrayList<Node>();
ArrayList<Node> ant = new ArrayList<Node>();
isGrading = false;
Token ent;
} 
{ ("{" ant = ExpressionList()"}"ent=<ENTAILMENT>"{" cq = ExpressionList()"}")
{
    HashMap<String, DownCable> sett = new HashMap<String,DownCable>();
  if(ent.image.trim().toLowerCase().equals("&=>"))
{
    Relation antecedent = network.getRelations().get("&ant");
    Relation consequent = network.getRelations().get("cq");
    HashMap<String, Node> antHash = new HashMap<String, Node>();
    HashMap<String, Node> cqHash = new HashMap<String, Node>();
    Node andEntailmentNode = null;
    for (Node a : ant)
      antHash.put(a.getName(), a);
    DownCable antDC = new DownCable(antecedent, new NodeSet(antHash));
    for (Node a : cq)
      cqHash.put(a.getName(), a);
    DownCable cqDC = new DownCable(consequent, new NodeSet(cqHash));
   if (quantifier)
         { 
          DownCable quant = new DownCable(network.getRelations().get("forall"), new NodeSet(varNodesForall));
          sett.put(quant.getRelation().getName(), quant);
        }
      sett.put(antDC.getRelation().getName(), antDC);
      sett.put(cqDC.getRelation().getName(), cqDC);
      DownCableSet dcs = new DownCableSet(sett);
      Node shouldCreate = compareMolecularNode(dcs);
      try {
        if(shouldCreate==null)
        andEntailmentNode = network.createNode("andentailment", new DownCableSet(sett));
        else
        andEntailmentNode = shouldCreate;
      } catch (NoSuchTypeException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
      }
    
    return andEntailmentNode;
}
else {
  if(ent.image.trim().toLowerCase().equals("&=>"))
{   
    Relation antecedent = network.getRelations().get("ant");
    Relation consequent = network.getRelations().get("cq");
    HashMap<String, Node> antHash = new HashMap<String, Node>();
    HashMap<String, Node> cqHash = new HashMap<String, Node>();
    Node orEntailmentNode = null;
    for (Node a : ant)
      antHash.put(a.getName(), a);
    DownCable antDC = new DownCable(antecedent, new NodeSet(antHash));
    for (Node a : cq)
      cqHash.put(a.getName(), a);
    DownCable cqDC = new DownCable(consequent, new NodeSet(cqHash));
    if (quantifier)
         { 
          DownCable quant = new DownCable(network.getRelations().get("forall"), new NodeSet(varNodesForall));
          sett.put(quant.getRelation().getName(), quant);
        }
      sett.put(antDC.getRelation().getName(), antDC);
      sett.put(cqDC.getRelation().getName(), cqDC);
        DownCableSet dcs = new DownCableSet(sett);
        Node shouldCreate = compareMolecularNode(dcs);
        try {
          if (shouldCreate == null)
            orEntailmentNode = network.createNode("orentailment", new DownCableSet(sett));
          else
            orEntailmentNode = shouldCreate;
        } catch (NoSuchTypeException e) {
          // TODO Auto-generated catch block
          e.printStackTrace();
        }
    
    return orEntailmentNode;
} else 
{
        String i = ent.image.trim().toLowerCase().charAt(0) + "";
        Relation antecedent = network.getRelations().get("&ant");
        Relation consequent = network.getRelations().get("cq");
        HashMap<String, Node> antHash = new HashMap<String, Node>();
        HashMap<String, Node> cqHash = new HashMap<String, Node>();
        Node iEntailmentNode = null;
        Node iNode = null;
        try {
          iNode = network.createNode(i, "individualNode");
          DownCable iDC = new DownCable(network.getRelations().get("i"), new NodeSet(iNode));
          for (Node a : ant)
            antHash.put(a.getName(), a);
          DownCable antDC = new DownCable(antecedent, new NodeSet(antHash));
          for (Node a : cq)
            cqHash.put(a.getName(), a);
          DownCable cqDC = new DownCable(consequent, new NodeSet(cqHash));

          if (quantifier)
         { 
          DownCable quant = new DownCable(network.getRelations().get("forall"), new NodeSet(varNodesForall));
          sett.put(quant.getRelation().getName(), quant);
        }
            sett.put(antDC.getRelation().getName(), antDC);
            sett.put(cqDC.getRelation().getName(), cqDC);
            sett.put(iDC.getRelation().getName(), iDC);
          DownCableSet dcs = new DownCableSet(sett);
          Node shouldCreate = compareMolecularNode(dcs);
          if (shouldCreate == null)
            iEntailmentNode = network.createNode("numentailment", new DownCableSet(sett));
          else
            iEntailmentNode = shouldCreate;
        } catch (NoSuchTypeException e) {
          // TODO Auto-generated catch block
          e.printStackTrace();
        }
        {
          if ("" != null)
            return iEntailmentNode;
        }

      }
}
}

}

Node negatedProp() : 
{
  firstExpression = false;
  Node node = null;
  isGrading = false;
}
{ 
  "~"node = Expression()
  {
    Node negatedNode = null;
      try {
        negatedNode = node.createNegation(node);
      } catch (NoSuchTypeException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
      }
    return negatedNode;
  }    
  }


Node gradedProp() : 
{
  Node node = null;
  String gradeValue;
  if(firstExpression || isGrading)
   {
    levelsCount++;
    firstExpression = false;
   }
}
{ 
  "g{"node = Expression()","gradeValue = <NUMBER>.image"}"
  {
    gradeValue = gradeValue.trim();
    // Relations
    Relation grade = network.getRelations().get("grade");
    Relation prop = network.getRelations().get("prop");

    // nodes
    Node gradeNode = null;
    Node molecNode = null;
    try {
      gradeNode = network.createNode(gradeValue, "individualnode");
      // cables
      DownCable gradeDC = new DownCable(grade, new NodeSet(gradeNode));
      DownCable propDC = new DownCable(prop, new NodeSet(node));
      DownCableSet alldcs = new DownCableSet(gradeDC, propDC);
      Node shouldCreate = compareMolecularNode(alldcs);
      if (shouldCreate == null)
        molecNode = network.createNode("propositionnode", alldcs);
      else
        molecNode = shouldCreate;
    } catch (NoSuchTypeException e) {
      // TODO Auto-generated catch block
      e.printStackTrace();
    }
    
    return molecNode;
    
  }
}


Node Predicate() : {
  Token num;
  Token predicateName;
  firstExpression = false;
  isGrading = false;
}

{
  predicateName=<PREDICATE_NAME_BRACKET>( Arguments(predicateName.image.toLowerCase()))")"
  {
    String pNodeName = predicateName.image.trim().toLowerCase();
    pNodeName = pNodeName.substring(0, pNodeName.length() - 1);
    Node pNode = null;
    Node molec = null;
    Relation rel = null ;
    try {
       pNode = network.createNode(pNodeName, "propositionnode");
       if(mode==1)
           rel = network.createRelation("r", "propositionnode", Adjustability.EXPAND, 2);
       if(mode == 2)
           rel = network.createRelation("rel" + pNodeName, "propositionnode", Adjustability.EXPAND, 2);
        if (rel == null && mode != 3) {
          throw new ParseException("rel is null");
      }
      if (mode != 3)
      {
      DownCable lastCable = new DownCable(rel, new NodeSet(pNode));
      allDCB.put(lastCable.getRelation().getName(), lastCable);
      }
      HashMap<String, DownCable> cloneAllDCB = new HashMap<String, DownCable>();
      for (DownCable x : allDCB.values())
        cloneAllDCB.put(x.getRelation().getName(), x);
      DownCableSet dcs = new DownCableSet(cloneAllDCB);
      Node shouldCreate = compareMolecularNode(dcs);
      if (shouldCreate == null)
        molec = network.createNode("propositionnode", dcs);
      else
        molec = shouldCreate;
      allDCB.clear();

    } catch (NoSuchTypeException e) {
      // TODO Auto-generated catch block
      e.printStackTrace();
    }
          return molec;

  }
}

void Arguments(String pName) : 
{
  ArrayList<Node> leafNodes = new ArrayList<Node>();
  Node arg;
  pName = pName.substring(0, pName.length() - 1);
}
{
 
   arg = Argument() { leafNodes.add(arg); }
  (
    "," arg = Argument() { leafNodes.add(arg); }
  )*
    {
    if (mode == 3) {
      if (!caseFrames.containsKey(pName))
        throw new ParseException("No Such Case Frame.");
      ArrayList<String> frame = caseFrames.get(pName);
      Relation firstRel = null;
      if (frame.get(0) != "null") {
        firstRel = network.createRelation(frame.get(1), "propositionnode", Adjustability.EXPAND, 2);
        DownCable dcb = null;
        try {
          dcb = new DownCable(firstRel, new NodeSet(network.createNode(pName, "propositionnode")));
          allDCB.put(dcb.getRelation().getName(), dcb);

        } catch (NoSuchTypeException e) {
          // TODO Auto-generated catch block
          e.printStackTrace();
        }
      }
      for (int i = 0; i < leafNodes.size(); i++) {
        Relation r = network.createRelation(frame.get(i + 1), "propositionnode", Adjustability.EXPAND, 2);
        DownCable dcb = new DownCable(r, new NodeSet(leafNodes.get(i)));
        allDCB.put(dcb.getRelation().getName(), dcb);
      }

    } else {
      for (int i = 0; i < leafNodes.size(); i++) {
        Node variableN = leafNodes.get(i);
        Relation rel = null;
        if (mode == 1)
          rel = network.createRelation("a" + (i + 1), "propositionnode", Adjustability.EXPAND, 2);
        if (mode == 2)
          rel = network.createRelation("rel - arg#" + pName + (i + 1), "propositionnode", Adjustability.EXPAND, 2);
        if (rel == null) 
          throw new ParseException("rel is null");
        DownCable dcb = new DownCable(rel, new NodeSet(variableN));
        allDCB.put(dcb.getRelation().getName(), dcb);
      }
    }
  }
 
 
}

Node Argument() : 
{Token Argument;
Token var=null;
Node leafNode = null;
}
{
 ( Argument=<STRING>(var=<VARIABLE>)? 
  {String argString = Argument.image.trim().toLowerCase();
  System.out.println(argString);   
        try {
          if (var != null)
            leafNode = network.createVariableNode(argString, "propositionnode");
          else
            leafNode = network.createNode(argString, "propositionnode");
        } catch (NoSuchTypeException e) {
          // TODO Auto-generated catch block
          e.printStackTrace();
        }
        return leafNode;
  }
  )
  |
  leafNode = Expression()
  {
    return leafNode;
  }

}


void defineFrame() throws ParseException : 
{
    ArrayList<String> allRelationNames = new ArrayList<String>();
    String relName;
    Token predicateName;
}
{
predicateName = <PREDICATE_NAME_BRACKET> relName = relationName() {if (!allRelationNames.contains(relName))
      allRelationNames.add(relName);}
(
  "," relName = relationName() { if (!allRelationNames.contains(relName))
      allRelationNames.add(relName);} 
)* ")"<EOF>
{
    String predName = predicateName.image.trim().toLowerCase();
    predName = predName.substring(0, predName.length() - 1);

    // Add listToAdd to listOfLists
    boolean isFirst = true;
    caseFrames.put(predName, allRelationNames);
    String output = "Case Frame " + predName + "(";
    for (String s : allRelationNames) {
      if (!isFirst)
        output += ", " + s;
      else
        output += s;
    }
    output += ") is Defined.";
    CLI.print(output);
}


}


String relationName() throws ParseException :
{Token s; 
}
{
   s= <STRING>
    {
      String relationName = s.image.trim().toLowerCase();
      return relationName;
    }
}


void Command() throws ParseException :
{
    Token stringToken;
     Token t = null;
        Token wffNameList = null;
       Token attitudeSet = null;
}
{ 
    (
        <currContext>
        {
         try {
        String s = ContextController.getCurrContextName();
        System.out.println(s);
      } catch (Exception e) {
        System.out.println("No Current Context");
      }

        }
    |
        <GetAttitudeNames>
        { 
        HashMap<String, Integer> attitudeNames = ContextController.getAttitudes().getSet();
            System.out.println("List of attitude names:");

          // Iterate over the attitude names and print them
        for (String key : attitudeNames.keySet()) {
          System.out.println(key);
        }
        }
    | <MODE1>
    {
      mode = 1;
       System.out.println("Operating in mode 1 (Default)");
      System.out.println(mode);

    } 
    | <MODE2>
    {
      mode = 2;
      System.out.println("Operating in mode 2");
      System.out.println(mode);

    }
    | <MODE3>
    {
      mode = 3;
      System.out.println("Operating in mode 3");
      System.out.println(mode);


    }
    |
    defineContext()
    )
    |
    ("define-frame" defineFrame())
    |
    (
      "define-semantic" defineSemantic()
    )
    |
    {
    Token CName;
   }
    ("add-bridge" Bridge())
    {
       HashMap<String, HashMap<String, Node>> molecN = network.getMolecularNodes();
      for(HashMap<String, Node> x : molecN.values()){
       for(Node n : x.values()){
        System.out.println(n.toString());
       }

    }
    }
    |
    setCurrentContext()

    |
    getAllContexts()
    |
    forwardInference()
    |
    activate()
    |
    AssertActivate()
    |
 setCurrentAttitude()
  |
    AddToContext()
    |
    RemoveFromContext()
    |
    definePath()
    |
    "define-relation" Relation()
    |
    DescribeContext()
    |
    getAllSupported()
   
    |
    performAct()
    |
    clearNetwork()
    |
    clearInfer()
    |
    "back-infer"backwardInference()
    |
    "ask-if-true"Ask()
    |
    "ask-if-not"AskifNot()
    |
    "ask-why"AskWh()
    |
    "ask-whynot"AskWhNot()
    }


void clearNetwork() throws ParseException :
{}
{
  "clear-network"
  {
    network.setBaseNodes(new HashMap<String,Node>());
    network.setNodes(new HashMap<Integer,Node>());
    network.setMolecularNodes(new HashMap<String,HashMap<String,Node>>());
    network.setRelations(new HashMap<String,Relation>());
    network.getPropositionNodes().clear();

    CLI.print("Network is Cleared.");
  }
}

void clearInfer() throws ParseException :
{}
{
  "clear-infer"
  {
        String x;
  }

}


void performAct() throws ParseException :
{
  Node node = null;
  ActNode actNode = null;
}
{
  "perform-act" node = Act()
  {
    actNode = (ActNode)node;

    try {
      actNode.perform();
    } catch (NoSuchTypeException e) {
      // TODO Auto-generated catch block
      CLI.print(e.getMessage());
    } catch (NoPlansExistForTheActException e) {
      // TODO Auto-generated catch block
      CLI.print(e.getMessage());
    } catch (DirectCycleException e) {
      // TODO Auto-generated catch block
      CLI.print(e.getMessage());
    }
  }

}

void defineNonPrimitive() throws ParseException :
{
  ActNode plan = null;
  String actName  = null;
  boolean p = false;
}
{
  "define-nonprimitive-act" actName = <STRING>.image (plan = Act(){p= true;})?
  {
    if(p){
      
    }
  }
  

}

void definePrimitive() throws ParseException :
{
  String fileName = null;
  String actName  = null;
  boolean p = false;
}
{
  "define-primitive-act" actName = <STRING>.image fileName = <STRING>.image
  {
  
  }
  

}




void getAllSupported() throws ParseException :
{}
{
  "get-supported"
  {
    HashMap<Integer, ArrayList<String>> allWffs = wffs;
    if (allWffs != null) {
      for (ArrayList<String> list : allWffs.values()) {
        for (int i = 0; i < list.size(); i++) {
          if (i == 0)
            CLI.print(list.getFirst() + " is Supported in :");
          else
            CLI.print(list.get(i));
        }
      }
    } else 
      CLI.print("No Hypothesis Supported in Any Context.");
  }
}


  void DescribeContext() throws ParseException :
{
  String CName=null;
}
{
"describe-context" (CName = <STRING>.image)?
{
    if (CName == null) {
      try{
      CName = controller.getCurrContextName();
      CName = CName.trim();
      }catch(Exception e){
        CLI.print("Set Default Context First.");
      }
      
    }
    else{
      CName = CName.trim();
      if(!controller.getContextSet().getSet().containsKey(CName.trim()))
        throw new ParseException("Context Does Not Exist.");
          CLI.print("Hypothesis in Context " + CName + ":");
    for (ArrayList<String> contexts : wffs.values()) {
      String wffName = contexts.get(0);
      for (int i = 1; i < contexts.size(); i++) {
        String cxt = contexts.get(i);
        String[] name_attitude = cxt.split("_");
        CLI.print(wffName + " supported in attitude " + name_attitude[1]);
      }

    }
    }


   

}
}


void RemoveFromContext() throws ParseException :
{
  String CName = null;
  boolean c = false;
  boolean a = false;
  Node node = null;
  String attitude = null;
}
{
  "remove-from-context"  ("c{"CName = <STRING>.image"}"{ c = true;})?
   ("a{"attitude = <STRING>.image"}"{ a = true ;})?
   node = Expression()
  {
    PropositionNode propNode = (PropositionNode) node;
    removeFromContext(CName, attitude, a, c, propNode);
    firstExpression = true;
    isGrading = true;
    levelsCount = 0;
  }
}



void AddToContext() throws ParseException :
{
    String attitude = null;
    String CName = null;
    Node nn;
    boolean c = false;
    boolean a = false;
}
 {  (
      "add-to-context"  ("c{"CName = <STRING>.image"}"{ c = true;})?
   ("a{"attitude = <STRING>.image"}"{ a = true ;})?
   nn = Expression()
    ){
      
    PropositionNode propNode = (PropositionNode) nn;
    addToContext(CName, attitude, a, c, propNode);
        firstExpression = true;
        isGrading = true;
        levelsCount = 0;
    // printing
    HashMap<String, HashMap<String, Node>> molecN = network.getMolecularNodes();
    for (HashMap<String, Node> x : molecN.values()) {
      for (Node n : x.values()) {
        System.out.println(n.toString());
      }
    }
    }
}




void backwardInference() throws ParseException :
{
    String attitude = null;
    String CName = null;
    Node node;
    boolean c = false;
    boolean a = false;
}
{
   ("c{"CName = <STRING>.image"}"{ c = true;})?
   ("a{"attitude = <STRING>.image"}"{ a = true ;})?
   node = Expression()
 {
    PropositionNode propNode = (PropositionNode) node;
    bInference(propNode, c, a, CName, attitude);
        firstExpression = true;
        isGrading = true;
        levelsCount = 0;
 }
} 


void AskWh() throws ParseException :
{
    String attitude = null;
    String CName = null;
    Node node;
    boolean c = false;
    boolean a = false;
}
{
   ("c{"CName = <STRING>.image"}"{ c = true;})?
   ("a{"attitude = <STRING>.image"}"{ a = true ;})?
   node = Expression()
 {
    PropositionNode propNode = (PropositionNode) node;
    bInference(propNode, c, a, CName, attitude);
    Hashtable<Integer, Hashtable<Substitutions, KnownInstance>> positiveInstances = propNode
        .getKnownInstances().positiveKInstances;

    Hashtable<Integer, Hashtable<Substitutions, KnownInstance>> negativeInstances = propNode
        .getKnownInstances().negativeKInstances;
    for (Hashtable<Substitutions, KnownInstance> value : positiveInstances.values()) {
      for (Substitutions sub : value.keySet()) {
        for (HashMap.Entry<Node, Node> entry : sub.getMap().entrySet()) {
          CLI.print("Variable: " + entry.getKey().toString() + ", Value: " + entry.getValue().toString());
        }
      }
    }
    for (Hashtable<Substitutions, KnownInstance> value : negativeInstances.values()) {
      for (Substitutions sub : value.keySet()) {
        for (HashMap.Entry<Node, Node> entry : sub.getMap().entrySet()) {
          CLI.print("Variable: " + entry.getKey().toString() + ", Value: " + entry.getValue().toString());
        }
      }
    }
        firstExpression = true;
        isGrading = true;
        levelsCount = 0;
 }
} 

void AskWhNot() throws ParseException :
{
    String attitude = null;
    String CName = null;
    Node node;
    boolean c = false;
    boolean a = false;
}
{
   ("c{"CName = <STRING>.image"}"{ c = true;})?
   ("a{"attitude = <STRING>.image"}"{ a = true ;})?
   node = Expression()
 {
    PropositionNode propNode = (PropositionNode) node;
    bInference(propNode, c, a, CName, attitude);
    PropositionNode negatedProp = null;
    try {
      negatedProp = (PropositionNode) propNode.createNegation(propNode);
    } catch (NoSuchTypeException e) {
      // TODO Auto-generated catch block
      CLI.print(e.getMessage());
    }
    Hashtable<Integer, Hashtable<Substitutions, KnownInstance>> positiveInstances = negatedProp
        .getKnownInstances().positiveKInstances;

    Hashtable<Integer, Hashtable<Substitutions, KnownInstance>> negativeInstances = negatedProp
        .getKnownInstances().negativeKInstances;
    for (Hashtable<Substitutions, KnownInstance> value : positiveInstances.values()) {
      for (Substitutions sub : value.keySet()) {
        for (HashMap.Entry<Node, Node> entry : sub.getMap().entrySet()) {
          CLI.print("Variable: " + entry.getKey().toString() + ", Value: " + entry.getValue().toString());
        }
      }
    }
    for (Hashtable<Substitutions, KnownInstance> value : negativeInstances.values()) {
      for (Substitutions sub : value.keySet()) {
        for (HashMap.Entry<Node, Node> entry : sub.getMap().entrySet()) {
          CLI.print("Variable: " + entry.getKey().toString() + ", Value: " + entry.getValue().toString());
        }
      }
    }
        firstExpression = true;
        isGrading = true;
        levelsCount = 0;
 }
} 


void AskifNot() throws ParseException :
{
    String attitude = null;
    String CName = null;
    Node node;
    boolean c = false;
    boolean a = false;
}
{
   ("c{"CName = <STRING>.image"}"{ c = true;})?
   ("a{"attitude = <STRING>.image"}"{ a = true ;})?
   node = Expression()
 {
    PropositionNode propNode = (PropositionNode) node;
    bInference(propNode, c, a, CName, attitude);
    Hashtable<Integer, Hashtable<Substitutions, KnownInstance>> negativeInstances = propNode
        .getKnownInstances().negativeKInstances;
    for (Hashtable<Substitutions, KnownInstance> value : negativeInstances.values()) {
      for (KnownInstance KI : value.values()) {
        CLI.print(KI.toString());
      }
    }
        firstExpression = true;
        isGrading = true;
        levelsCount = 0;
 }
}

void Ask() throws ParseException :
{
    String attitude = null;
    String CName = null;
    Node node;
    boolean c = false;
    boolean a = false;
}
{
   ("c{"CName = <STRING>.image"}"{ c = true;})?
   ("a{"attitude = <STRING>.image"}"{ a = true ;})?
   node = Expression()
 {
    PropositionNode propNode = (PropositionNode) node;
    bInference(propNode, c, a, CName, attitude);
    Hashtable<Integer, Hashtable<Substitutions, KnownInstance>> positiveInstances = propNode
        .getKnownInstances().positiveKInstances;
    for (Hashtable<Substitutions, KnownInstance> value : positiveInstances.values()) {
      for (KnownInstance KI : value.values()) {
        CLI.print(KI.toString());
      }
    }
        firstExpression = true;
        isGrading = true;
        levelsCount = 0;
 }
} 



void forwardInference() throws ParseException :
{
  Node node = null;
  String CName = null;
  String attitude = null;
  boolean c = false;
  boolean a = false;
}
{
   "forward-infer"("c{"CName = <STRING>.image"}"{ c = true;})?
   ("a{"attitude = <STRING>.image"}"{ a = true ;})?
   node = Expression()
    {

    PropositionNode propNode = (PropositionNode) node;
    fInference(propNode, c, a, CName, attitude);
        firstExpression = true;
        isGrading = true;
        levelsCount = 0;
    }
} 

void activate() throws ParseException:
{
  String CName = null;
  boolean c = false;
  boolean a = false;
  Node node = null;
  String attitude = null;
}
{
  "activate-node"("c{"CName = <STRING>.image"}"{ c = true;})?
   ("a{"attitude = <STRING>.image"}"{ a = true ;})?
   node = Expression()
   {
    PropositionNode propNode = (PropositionNode) node;

    Collection<Node> set = propNode.getDirectParents().getValues();
    for (Node n : set) {
      if (isSupported(propNode, c, a, CName, attitude) == 1)
        fInference(propNode, c, a, CName, attitude);
    }
        firstExpression = true;
        isGrading = true;
        levelsCount = 0;
   }
}

void AssertActivate() throws ParseException:
{
  String CName = null;
  boolean c = false;
  boolean a = false;
  Node node = null;
  String attitude = null;
}
{
  "activate-node!"("c{"CName = <STRING>.image"}"{ c = true;})?
   ("a{"attitude = <STRING>.image"}"{ a = true ;})?
   node = Expression()
   {
    PropositionNode propNode = (PropositionNode) node;
    addToContext(CName, attitude, a, c, propNode);
    Collection<Node> set = propNode.getDirectParents().getValues();
    for (Node n : set) {
      if (isSupported(propNode, c, a, CName, attitude) == 1)
        fInference(propNode, c, a, CName, attitude);
    }
        firstExpression = true;
        isGrading = true;
        levelsCount = 0;
   }
}

void getAllContexts() throws ParseException :
{}
{
  "get-contexts"
  {
    
    HashMap<String, Context> set = controller.getContextSet().getSet();
     System.out.println("All Contexts Defined:");
    for(String cName  : set.keySet()){
      System.out.println(cName);
    }
  }
}

void setCurrentContext() throws ParseException :
{
  String cName; 
}
{
  "set-curr-context" cName = <STRING>.image
  {
    cName = cName.trim().toLowerCase();
    try {
      controller.setCurrContext(cName);
      CLI.print("Current Context is Set to " + cName);
    } catch (Exception e) {
      System.out.println(e.getMessage());
      // TODO: handle exception
    }

  }
}

void setCurrentAttitude() throws ParseException :
{
  String attitude; 
}
{
  "set-attitude" attitude = <STRING>.image
  {
    attitude = attitude.trim().toLowerCase();
    
    Integer num = controller.getAttitudeNumber(attitude);
    if(num == null)
    {
      CLI.print("no such attitude. The current default attitude is " + controller.getAttitudeName(defaultAttitude)+".");

    }
    else{
      defaultAttitude = num;
      CLI.print("The default attitude has been set to "+attitude+".");
    }


  }
}


Node Bridge() throws ParseException :
{
  HashMap<Node, Integer> antec = new HashMap<Node, Integer>();
  HashMap<Node, Integer> conseq = new HashMap<Node, Integer>();
}
{
  "{"antec = bridgeExpressionList()"}""{" conseq = bridgeExpressionList()"}"
  {
        HashMap<Integer, ArrayList<Node>> antecGroupedByAttitude = groupByValue(antec);
    HashMap<Integer, ArrayList<Node>> conseqGroupedByAttitude = groupByValue(conseq);
    HashMap<String, DownCable> allDCs = new HashMap<String,DownCable>();
    for(Integer n : antecGroupedByAttitude.keySet())
      System.out.println(n+" lol");
    for (Integer n : antecGroupedByAttitude.keySet()) {
      ArrayList<Node> nodes = antecGroupedByAttitude.get(n);
      Relation antRel = network.createRelation(n + "-ant", "propositionnode", Adjustability.EXPAND, 2);
      NodeSet set = new NodeSet();
      for (Node node : nodes) 
        set.add(node);
      DownCable dc = new DownCable(antRel, set);
      allDCs.put(antRel.getName(), dc);
    }

    for (Integer n : conseqGroupedByAttitude.keySet()) {
      ArrayList<Node> nodes = conseqGroupedByAttitude.get(n);
      Relation conseqRel = network.createRelation(n + "-cq", "propositionnode", Adjustability.EXPAND, 2);
      NodeSet set = new NodeSet();
      for (Node node : nodes) 
        set.add(node);
      DownCable dc = new DownCable(conseqRel, set);
      allDCs.put(conseqRel.getName(), dc);
    }
    Node bridgeNode = null;
    DownCableSet allDBs = new DownCableSet(allDCs);
    try {
      Node shouldCreate = compareMolecularNode(allDBs);
      if (shouldCreate == null)
        bridgeNode = network.createNode("bridgerule", allDBs);
      else
        bridgeNode = shouldCreate;
    } catch (NoSuchTypeException e) {
      // TODO Auto-generated catch block
      e.printStackTrace();
    }
    return bridgeNode;

  }

}

 HashMap<Node, Integer> bridgeExpressionList() : 
{
  ArrayList<Node> nodes = new ArrayList<Node>();
  Node arg;
  ArrayList<String> attitudes = new ArrayList<String>();
  String attitude;
}
{
 "{" arg = Expression()"," attitude = <STRING>.image"}"  { nodes.add(arg); attitudes.add(attitude.trim().toLowerCase());}
  (
  "," "{"  arg = Expression()"," attitude=<STRING>.image"}"{  nodes.add(arg); attitudes.add(attitude.trim().toLowerCase()); } 
  )*
  {
    ArrayList<Integer> attitudeNo = new ArrayList<Integer>();
   for(String s  : attitudes) {
    Integer num = controller.getAttitudeNumber(s);
    if(num==null)
      throw new ParseException("No such attitude");
    attitudeNo.add(num);
   }
    HashMap<Node, Integer> node_attitude = new HashMap<Node, Integer>();
    for(int i = 0; i<nodes.size();i++){
      node_attitude.put(nodes.get(i),attitudeNo.get(i));
    }
    return node_attitude;
  }
  
}

void defineSemantic() throws ParseException :
{
  String typeName;
  String superClass = null;

}
{
  ("[" typeName = <STRING>.image"]" ("["superClass = <STRING>.image"]")?)
{
    typeName = typeName.trim();
    superClass = superClass.trim();

    if (network.getUserDefinedClasses().containsKey(typeName)) {
      if (true)
        throw new ParseException("User Defined Class with the Same Name Already Exists.");
    }

    while (true) {
      CLI.print("Create Custom Methods to Create Your Custom Class Using Command 'custom-method' ");
      String s = CLI.readInput();
      if (s.trim().toLowerCase().equals("done")){
        try {
          network.createNewSemanticType(typeName, superClass, customMethods);
        } catch (Exception e) {
          // TODO Auto-generated catch block
          e.printStackTrace();
        }
        break;
      }
      MindGRAF_Parser parser = new MindGRAF_Parser(
          new StringReader(s));
          
      try {
        parser.customMethod();
      } catch (ParseException e) {
        System.out.println();
        System.out.println(e.getMessage());

        // TODO Auto-generated catch block

        continue;
      }
    }
}

}

void customMethod() throws ParseException :
{
  String methodName = null;
  String returnType  = null;
  ArrayList<String> params = new ArrayList<String>();
  ArrayList<String> args = new ArrayList<String>();
  String methodCode = null;

  
}
{
(  "custom-method" "["methodName = <STRING>.image"]" "["params = methodParams()"]" "["args = methodArgs()"]" "["returnType = <STRING>.image"]" methodCode = methodCode()
{
    methodName = methodName.trim();
    returnType = returnType.trim();
  
    if (args.size() != params.size())
      throw new ParseException("args != params");
    ArrayList<Class<?>> methodParams = new ArrayList<Class<?>>();
    CustomMethod customMethod = null;
    try {
      for (int i = 0; i < params.size(); i++)
        methodParams.add(Class.forName(params.get(i)));
      customMethod = new CustomMethod(methodName, methodCode, Class.forName(returnType), methodParams,
          args);
          customMethods.add(customMethod);
    } catch (ClassNotFoundException e) {
      // TODO: handle exception
    }
}
)
}

String methodCode() throws ParseException :
{
  StringBuilder methodCodeBuilder = new StringBuilder();
}
{
  (
    <STRING> | "." | "," | ";" | ":" | "(" | ")" | "[" | "]" | "{" | "}" | "<" | ">" | "'" 
    | "\"" | "-" | "+" | "*" | "/" | "\\" | "=" | "&" | "|" | "^" | "!" | "?" | "%" | "@" 
    | "#" | "$" | "~"|<NUMBER>
  )+
  {
    methodCodeBuilder.append(token.image);
    return methodCodeBuilder.toString();

  }
}



ArrayList<String> methodArgs() throws ParseException :
{
  ArrayList<String> allArgs = new ArrayList<String>();
  String arg;
}
{
  arg = methodArg(){allArgs.add(arg);}("," arg = methodArg(){allArgs.add(arg);})*
  {return allArgs;}
}

String methodArg() throws ParseException :
{
  Token arg = null;
}
{
  (arg = <STRING> | arg = <NUMBER>)
  {
    String a = arg.image.trim();
    return a;
  }
  {
    throw new ParseException("Invalid argument");
  }
}


ArrayList<String> methodParams() throws ParseException :
{
  ArrayList<String> allParams = new ArrayList<String>();
  String arg;
}
{
  arg = methodParam(){allParams.add(arg);}("," arg = methodParam(){allParams.add(arg);})*
  {return allParams;}
}

String methodParam() throws ParseException :
{
  Token param;
}
{
  param = <STRING>
  {
    String p = param.image.trim();
    return p;
  }
}


void automaticHandling() throws ParseException:
{}
{
 ( "set-automatic-handling on"
  {automaticHandling = true;}
  |
  "set-automatic-handling off"
  {automaticHandling = false;})
  {
        CLI.print("Enable Cache?");
    System.out.print(":");
    while (true) {
      String input = CLI.readInput();
      if (input.trim().toLowerCase().equals("exit")) {
      System.out.println("Session ended.");
      CLI.loop = false;
    }
      MindGRAF_Parser parser = new MindGRAF_Parser(
          new StringReader(input.trim()));
      try {
        parser.EnableCache();
        break;
      } catch (ParseException e) {
        CLI.print("Wrong Command.");
        System.out.print(":");
      }
    }
  }
}

void EnableCache() throws ParseException:
{}
{
 ( "set-cache on"
  {cacheEnabled = true;}
  |
  "set-cache off"
  {cacheEnabled = false;})
  {
      CLI.print("Enter Merge Function Number");
      System.out.print(":");
      while (true) {
      String input = CLI.readInput();
      if (input.trim().toLowerCase().equals("exit")) {
      System.out.println("Session ended.");
      CLI.loop = false;
    }
      MindGRAF_Parser parser = new MindGRAF_Parser(
          new StringReader(input.trim()));
      try {
        parser.MergeFunctionNumber();
        parser.MergeFunctionNumber();
        Set attitudeNames = new Set();
        attitudeNames.setSet(initialAttitudes);
        NetworkController.setUp(attitudeNames, consisAttitudeLists, uvbrEnabled, automaticHandling, cacheEnabled, mergeFN);
        break;
      } catch (ParseException e) {
        CLI.print("Wrong Command.");
        System.out.print(":");
      }
    }
  }
}


void MergeFunctionNumber() throws ParseException:
{
  String mfn;
}
{
  "set-mfn" mfn = <NUMBER>.image
  {
    mergeFN = mergeFN = Integer.parseInt(mfn);
  }
}

void UVBR() throws ParseException :
{ 
  Token value;

}
{
  (
    "set-uvbr on" 
    {
      uvbrEnabled=true;
      System.out.println("UVBR is ON");
      
    }
    
  |
    "set-uvbr off"
    { 
      uvbrEnabled=false;
      System.out.println("UVBR is OFF");



    }
  )
  {
    Set attitudeNames = new Set();
    attitudeNames.setSet(initialAttitudes);
    CLI.print("Set Automatic Handling:");
    System.out.print(":");
    while (true) {
      String input = CLI.readInput();
      if (input.trim().toLowerCase().equals("exit")) {
      System.out.println("Session ended.");
      CLI.loop = false;
    }
      MindGRAF_Parser parser = new MindGRAF_Parser(
          new StringReader(input.trim()));
      try {
        parser.automaticHandling();
        break;
      } catch (ParseException e) {
        CLI.print("Wrong Command.");
        System.out.print(":");
      }
    }
  }
  

}


  


void setAttitudes() throws ParseException :
{
    initialAttitudes.put("belief",0);
}
{
   ("set-attitudes" "{"attitude()(","attitude())*"}"
   {

    System.out.println("Attitudes Defined:");
    for(String key : initialAttitudes.keySet()){
    System.out.println(key);
   }

   })
   |
   <N>

}

void defineContext() throws ParseException :
{
  String CName;
}
{
  "define-context" "["CName = <STRING>.image"]" 
  {
    CName = CName.trim().toLowerCase();
    try{
    controller.createNewContext(CName);
    CLI.print("Context "+ CName +" is Created.");

    }catch(Exception e)
    {
      CLI.print(e.getMessage());
    }
  }
   
}

void wffAttitudeSet() throws ParseException :
{}
{
"{"<WFF_NAME>","<STRING>"}"
}







void attitude() throws ParseException :
{Token attitude;
}
{
attitude=<STRING>
{
String a = attitude.image.trim().toLowerCase();
if(initialAttitudes.containsKey(a))
throw new ParseException("duplicate attitudes");
initialAttitudes.put(a,attitudeNumber);
attitudeNumber++;
}
}



void TelescopableAttitudes() throws ParseException : 
{
  ArrayList<Integer> list = new ArrayList<Integer>();
}
{
   "set-telescopable" (list = telescopableAttitudeList())?
   {
    finalTelList = list;
    for (Integer in : list) {
                System.out.print(in + " ");
            System.out.println(); // Move to the next line after printing each inner list
        }
   }

}



ArrayList<Integer> telescopableAttitudeList() throws ParseException :
{
  Token attitude;
  ArrayList<Integer> telList = new ArrayList<Integer>();
  Integer att ;
}
{
("{"att = OneAttitudeInList(){telList.add(att);}(","att = OneAttitudeInList(){telList.add(att);})*"}")
{
  return telList;
}


}

Integer OneAttitudeInList() throws ParseException :
{
  Token attitude;
}
{
attitude=<STRING>
{
  String s = attitude.image.trim().toLowerCase();
  if(!initialAttitudes.containsKey(s))
    throw new ParseException("Not in initially Defined Attitudes");
  
  return initialAttitudes.get(s);
 

}
}






void underConsequenceAttitudes() throws ParseException : 
{
  ArrayList<Integer> list = new ArrayList<Integer>();
}
{
   "set-closed-consequence" (list = consequenceAttitudeList())?
   {
    finalConseqList = list;
    for (Integer in : list) {
                System.out.print(in + " ");
            System.out.println(); // Move to the next line after printing each inner list
        }
   }

}



ArrayList<Integer> consequenceAttitudeList() throws ParseException :
{
  Token attitude;
  ArrayList<Integer> conseqList = new ArrayList<Integer>();
  Integer att ;
}
{
("{"att = OneAttitudeInList(){conseqList.add(att);}(","att = OneAttitudeInList(){conseqList.add(att);})*"}")
{
  return conseqList;
}


}




void underConjunctionAttitudes() throws ParseException : 
{
  ArrayList<Integer> list = new ArrayList<Integer>();
}
{
   "set-closed-conjunction" (list = conjunctionAttitudeList())?
   {
    finalConjList = list;
    for (Integer in : list) {
                System.out.print(in + " ");
            System.out.println(); // Move to the next line after printing each inner list
        }
   }

}



ArrayList<Integer> conjunctionAttitudeList() throws ParseException :
{
  Token attitude;
  ArrayList<Integer> conjList = new ArrayList<Integer>();
  Integer att ;
}
{
("{"att = OneAttitudeInList(){conjList.add(att);}(","att = OneAttitudeInList(){conjList.add(att);})*"}")
{
  return conjList;
}


}






void consistentAttitudes() throws ParseException : 
{}
{
   "set-consistent-attitudes " (consisAttitudeList())+
   {

    for (ArrayList<Integer> list : consisAttitudeLists) {
            for (Integer num : list) {
                System.out.print(num + " ");
            }
            System.out.println(); // Move to the next line after printing each inner list
        }
   }

   

}


void consisAttitudeList() throws ParseException :
{
  Token attitude;
}
{
("{"OneAttitudeInConsisList()(","OneAttitudeInConsisList())*"}")
{
  ArrayList<Integer> finalConsisList = new ArrayList<Integer>();
  for(int i = 0;i<consisAttitudeList.size();i++){
    finalConsisList.add(consisAttitudeList.get(i));
  }

consisAttitudeLists.add(finalConsisList);
consisAttitudeList.clear();

  System.out.println("now printing all contents:");

    for (ArrayList<Integer> list : consisAttitudeLists) {
            for (Integer num : list) {
                System.out.print(num + " ");
            }
            System.out.println(); // Move to the next line after printing each inner list
        }
System.out.print(consisAttitudeList.size()+" the size..");
System.out.println(consisAttitudeList.size()+" the size..");
System.out.println(finalConsisList.size()+" the size of the final list");

}

}

void OneAttitudeInConsisList() throws ParseException :
{
  Token attitude;
}
{
attitude=<STRING>
{
  String s = attitude.image.trim().toLowerCase();
  if(!initialAttitudes.containsKey(s))
    throw new ParseException("Not in initially Defined Attitudes");
  currConsisAttitude = initialAttitudes.get(s);
  consisAttitudeList.add(currConsisAttitude);
 

}
}




