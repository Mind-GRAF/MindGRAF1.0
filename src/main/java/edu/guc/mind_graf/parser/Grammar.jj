/* ArithmeticExpression.jj */

options {
  // Generate the parser in a single class
  static = false;
}

// Define the parser class
PARSER_BEGIN(MindGRAF_Parser)
package edu.guc.mind_graf.parser;
import edu.guc.mind_graf.context.ContextController;
import java.util.ArrayList;
import java.util.HashMap;
import edu.guc.mind_graf.set.NodeSet;
import edu.guc.mind_graf.set.Set;
import edu.guc.mind_graf.cables.DownCable;
import edu.guc.mind_graf.cables.DownCableSet;
import edu.guc.mind_graf.caseFrames.Adjustability;
import java.util.Collection;
import edu.guc.mind_graf.exceptions.NoSuchTypeException;
import edu.guc.mind_graf.nodes.Node;
import edu.guc.mind_graf.relations.Relation;

public class MindGRAF_Parser {
      private ContextController controller = new ContextController();
      private int mode = 1;
      static boolean uvbrEnabled;
   
    
      //setting the attitudes 
      private static int attitudeNumber = 1;
      private static HashMap<String, Integer> initialAttitudes = new HashMap<String, Integer>();

     //setting the consistent attitudes
      private static ArrayList<ArrayList<Integer>> consisAttitudeLists = new ArrayList<ArrayList<Integer>>();
      private  static ArrayList<Integer> consisAttitudeList = new ArrayList<Integer>();
      private static int currConsisAttitude;

      //setting closed under conjunction Attitudes
      private static ArrayList<ArrayList<Integer>> conjunctionAttitudeLists = new ArrayList<ArrayList<Integer>>();
      private  static ArrayList<Integer> conjunctionAttitudeList = new ArrayList<Integer>();
      private static int currConjunctionAttitude;

      //setting closed under consequence Attitudes
      private static ArrayList<ArrayList<Integer>> consequenceAttitudeLists = new ArrayList<ArrayList<Integer>>();
      private  static ArrayList<Integer> consequenceAttitudeList = new ArrayList<Integer>();
      private static int currConseqAttitude;

       //setting telescopable Attitudes
      private static ArrayList<ArrayList<Integer>> teleAttitudeLists = new ArrayList<ArrayList<Integer>>();
      private  static ArrayList<Integer> teleAttitudeList = new ArrayList<Integer>();
      private static int currTeleAttitude;
      
      //mode1 creation of nodes
      private static  ArrayList<String> NodesNames = new ArrayList<String>();
      private static boolean isVariable;

        @SuppressWarnings("static-access")

  public static void main(String[] args) throws ParseException {
    // Instantiate the parser
    MindGRAF_Parser parser = new MindGRAF_Parser(System.in);
   /* try {
      // Start parsing
      parser.Start();

      System.out.println("Parsing successful!");
    } catch (ParseException e) {
      // Handle parsing errors
      System.err.println("Parsing failed: " + e.getMessage());
    }*/
  }
}


PARSER_END(MindGRAF_Parser)

// Define tokens
SKIP:  {"\t" | "\n" | "\r"|" "}
TOKEN :
{ 
  <NUMBER: (["0"-"9"])+>
| <currContext: "get-curr-context">
| <GetAttitudeNames: "get-attitudes">
| <MODE1: "set-mode-1">
| <MODE2: "set-mode-2">
| <MODE3: "set-mode-3">
| <N:"N"|"n">
| <BOOL:"true"|"false">
| < #IDENTIFIER: <LETTER> (<LETTER>|<DIGIT>)* >
| < #LETTER: ["_","a"-"z","A"-"Z"] >
| < #DIGIT: ["0"-"9"] >
| <ANDOR_THRESH: (("andor"|"thresh")"(")>
| <VARIABLE: "?">
| <WFF_NAME: "WFF"(<DIGIT>)+>
| <STRING: (["a"-"z", "A"-"Z"])+ (["a"-"z", "A"-"Z", "0"-"9", "_"])*>
| <PREDICATE_NAME_BRACKET: ((["a"-"z", "A"-"Z"])+ (["a"-"z", "A"-"Z", "0"-"9", "_"])*"(")>





}

// Define the grammar

void Expression() : {}
{
    AndOrExpression() | Predicate()
}

void AndOrExpression() : {Token connective;}
{
    <ANDOR_THRESH> <NUMBER> "," <NUMBER> ")" "{" ExpressionList() "}"
    {

    }
}

void ExpressionList() : {}
{
    Expression() ("," Expression())*
}

void Predicate() : {
  Token num;
  Token predicateName;
}

{
  predicateName=<PREDICATE_NAME_BRACKET>( num  = <NUMBER>",")? Arguments()")"
  {
  String predName = predicateName.image.trim().toLowerCase();
  predName = predName.substring(0,predName.length()-1);    
    if (mode == 1) {
      HashMap<String, DownCable> cableSet = new HashMap<String, DownCable>();
      try {
        Node n = controller.getNetwork().createNode(predName, "propositionnode");
        Relation r = controller.getNetwork().createRelation("r", "propositionnode",
            Adjustability.EXPAND, 2);
        DownCable c = new DownCable(r, new NodeSet(n));
        cableSet.put(r.getName(), c);

        for (int i = 0; i < NodesNames.size(); i++) {
          String nodeName = NodesNames.get(i);
          Node node;
          if(nodeName.charAt(nodeName.length() - 1)=='?')
            node = controller.getNetwork().createVariableNode(nodeName.substring(0,nodeName.length()-1), "propositionnode");
          else
            node = controller.getNetwork().createNode(nodeName, "propositionnode");
          Relation relation = controller.getNetwork().createRelation("a" + (i + 1), "propositionnode",
              Adjustability.EXPAND, 2);
          DownCable cable = new DownCable(relation, new NodeSet(node));
          cableSet.put(relation.getName(), cable);
        }
        NodesNames.clear();
        DownCableSet dcSet = new DownCableSet(cableSet);
        controller.getNetwork().createNode("propositionnode", dcSet);

        //printing
        
      } catch (NoSuchTypeException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
      }


    }
  }
}

void Arguments() : {}
{
  Argument() ("," Argument())*
}

void Argument() : 
{Token Argument;
Token var=null;}
{
 ( Argument=<STRING>(var=<VARIABLE>)?
  {
    String argString = Argument.image.trim().toLowerCase();
  if(var!=null)
  argString +='?';
  NodesNames.add(argString);

  })
  |
  ExpressionList()
}


void Command() throws ParseException :
{
    Token stringToken;
     Token t = null;
        Token wffNameList = null;
       Token attitudeSet = null;
}
{ 
    (
        <currContext>
        {
         try {
        String s = ContextController.getCurrContextName();
        System.out.println(s);
      } catch (Exception e) {
        System.out.println("No Current Context");
      }

        }
    |
        <GetAttitudeNames>
        { 
        HashMap<String, Integer> attitudeNames = ContextController.getAttitudes().getSet();
            System.out.println("List of attitude names:");

          // Iterate over the attitude names and print them
        for (String key : attitudeNames.keySet()) {
          System.out.println(key);
        }
        }
    | <MODE1>
    {
      mode = 1;
       System.out.println("Operating in mode 1 (Default)");
      System.out.println(mode);

    } 
    | <MODE2>
    {
      mode = 2;
      System.out.println("Operating in mode 2");
      System.out.println(mode);

    }
    | <MODE3>
    {
      mode = 3;
      System.out.println("Operating in mode 3");
      System.out.println(mode);


    }
    |("define-context " stringToken=<STRING>)defineContext()
    )
    |(
      "add-to-context" Expression() 
    )
    }

void UVBR() throws ParseException :
{ 
  Token value;
}
{
  (
    "set-uvbr" value=<BOOL>
    {
      String boolValue = value.image.trim().toLowerCase();
      if (boolValue.equals("true")) {
          uvbrEnabled=true;
      } else if (boolValue.equals("false")) {
          uvbrEnabled=false;
      } 
      System.out.println("UVBR is set to "+uvbrEnabled);
      Set attitudeNames = new Set();
      attitudeNames.setSet(initialAttitudes);
      controller.setUp(attitudeNames,consisAttitudeLists,uvbrEnabled);

      System.out.print("uvbr: "+controller.isUvbrEnabled());
      System.out.println("consis attitudes:" );
      for(ArrayList<Integer> i : controller.getConsistentAttitudes())
     { System.out.println("SET " + i+1);
      for( Integer x : i)
        System.out.print(x+" ");}
         System.out.print("attitudeNumbers");
      for(String key : controller.getAttitudes().getSet().keySet())
        System.out.println(key+": " +controller.getAttitudeNumber(key));
    }
       
  )
}


  


void Setup() throws ParseException :
{
    Token attitudeSetToken;
    HashMap<String, Integer> hash = new HashMap<String, Integer>();
    //controller.getAttitudes().setSet(hash);
    initialAttitudes.put("belief",0);
}
{
   ("set-attitudes" "{"attitude()(","attitude())*"}"
   {

    System.out.println("Attitudes Defined:");
    for(String key : initialAttitudes.keySet()){
    System.out.println(key);
   }
   

   })
   |
   <N>

}

void defineContext() throws ParseException :
{
  
}
{("{"wffAttitudeSet()(","wffAttitudeSet())*"}")
{

}
   
}

void wffAttitudeSet() throws ParseException :
{}
{
"{"<WFF_NAME>","<STRING>"}"
}

void attitude() throws ParseException :
{Token attitude;
}
{
attitude=<STRING>
{
String a = attitude.image.trim().toLowerCase();
if(initialAttitudes.containsKey(a))
throw new ParseException("duplicate attitudes");
initialAttitudes.put(a,attitudeNumber);
attitudeNumber++;
}
}

void underTeleAttitudes() throws ParseException : 
{}
{
   "set-telescopable " (teleAttitudeList())+
   {

    for (ArrayList<Integer> list : teleAttitudeLists) {
            for (Integer num : list) {
                System.out.print(num + " ");
            }
            System.out.println(); // Move to the next line after printing each inner list
        }
   }

}


void teleAttitudeList() throws ParseException :
{
  Token attitude;
}
{
("{"OneAttitudeInTeleList()(","OneAttitudeInTeleList())*"}")
{
  ArrayList<Integer> finalTeleList = new ArrayList<Integer>();
  for(int i = 0;i<teleAttitudeList.size();i++){
    finalTeleList.add(teleAttitudeList.get(i));
  }

teleAttitudeLists.add(finalTeleList);
teleAttitudeList.clear();

                System.out.println("now printing all contents:");

    for (ArrayList<Integer> list : teleAttitudeLists) {
            for (Integer num : list) {
                System.out.print(num + " ");
            }
            System.out.println(); // Move to the next line after printing each inner list
        }
System.out.print(teleAttitudeList.size()+" the size..");
System.out.println(teleAttitudeList.size()+" the size..");
System.out.println(finalTeleList.size()+" the size of the final list");

}

}

void OneAttitudeInTeleList() throws ParseException :
{
  Token attitude;
}
{
attitude=<STRING>
{
  String s = attitude.image.trim().toLowerCase();
  if(!initialAttitudes.containsKey(s))
    throw new ParseException("Not in initially Defined Attitudes");
  currTeleAttitude = initialAttitudes.get(s);
  teleAttitudeList.add(currTeleAttitude);
 

}
}










void underConsequenceAttitudes() throws ParseException : 
{}
{
   "set-closed-consequence " (consequenceAttitudeList())+
   {

    for (ArrayList<Integer> list : consequenceAttitudeLists) {
            for (Integer num : list) {
                System.out.print(num + " ");
            }
            System.out.println(); // Move to the next line after printing each inner list
        }
   }

}


void consequenceAttitudeList() throws ParseException :
{
  Token attitude;
}
{
("{"OneAttitudeInConsequenceList()(","OneAttitudeInConsequenceList())*"}")
{
  ArrayList<Integer> finalConsequenceList = new ArrayList<Integer>();
  for(int i = 0;i<consequenceAttitudeList.size();i++){
    finalConsequenceList.add(consequenceAttitudeList.get(i));
  }

consequenceAttitudeLists.add(finalConsequenceList);
consequenceAttitudeList.clear();

                System.out.println("now printing all contents:");

    for (ArrayList<Integer> list : consequenceAttitudeLists) {
            for (Integer num : list) {
                System.out.print(num + " ");
            }
            System.out.println(); // Move to the next line after printing each inner list
        }
System.out.print(consequenceAttitudeList.size()+" the size..");
System.out.println(consequenceAttitudeList.size()+" the size..");
System.out.println(finalConsequenceList.size()+" the size of the final list");

}

}

void OneAttitudeInConsequenceList() throws ParseException :
{
  Token attitude;
}
{
attitude=<STRING>
{
  String s = attitude.image.trim().toLowerCase();
  if(!initialAttitudes.containsKey(s))
    throw new ParseException("Not in initially Defined Attitudes");
  currConseqAttitude = initialAttitudes.get(s);
  consequenceAttitudeList.add(currConseqAttitude);
 

}
}



void underConjunctionAttitudes() throws ParseException : 
{}
{
   "set-closed-conjunction " (conjunctionAttitudeList())+
   {

    for (ArrayList<Integer> list : conjunctionAttitudeLists) {
            for (Integer num : list) {
                System.out.print(num + " ");
            }
            System.out.println(); // Move to the next line after printing each inner list
        }
   }

}



void conjunctionAttitudeList() throws ParseException :
{
  Token attitude;
}
{
("{"OneAttitudeInConjunctionList()(","OneAttitudeInConjunctionList())*"}")
{
  ArrayList<Integer> finalConjunctionList = new ArrayList<Integer>();
  for(int i = 0;i<conjunctionAttitudeList.size();i++){
    finalConjunctionList.add(conjunctionAttitudeList.get(i));
  }

conjunctionAttitudeLists.add(finalConjunctionList);
conjunctionAttitudeList.clear();

                System.out.println("now printing all contents:");

    for (ArrayList<Integer> list : conjunctionAttitudeLists) {
            for (Integer num : list) {
                System.out.print(num + " ");
            }
            System.out.println(); // Move to the next line after printing each inner list
        }
System.out.print(conjunctionAttitudeList.size()+" the size..");
System.out.println(conjunctionAttitudeList.size()+" the size..");
System.out.println(finalConjunctionList.size()+" the size of the final list");

}

}

void OneAttitudeInConjunctionList() throws ParseException :
{
  Token attitude;
}
{
attitude=<STRING>
{
  String s = attitude.image.trim().toLowerCase();
  if(!initialAttitudes.containsKey(s))
    throw new ParseException("Not in initially Defined Attitudes");
  currConsisAttitude = initialAttitudes.get(s);
  conjunctionAttitudeList.add(currConjunctionAttitude);
 

}
}





void consistentAttitudes() throws ParseException : 
{}
{
   "set-consistent-attitudes " (consisAttitudeList())+
   {

    for (ArrayList<Integer> list : consisAttitudeLists) {
            for (Integer num : list) {
                System.out.print(num + " ");
            }
            System.out.println(); // Move to the next line after printing each inner list
        }
   }

   

}


void consisAttitudeList() throws ParseException :
{
  Token attitude;
}
{
("{"OneAttitudeInConsisList()(","OneAttitudeInConsisList())*"}")
{
  ArrayList<Integer> finalConsisList = new ArrayList<Integer>();
  for(int i = 0;i<consisAttitudeList.size();i++){
    finalConsisList.add(consisAttitudeList.get(i));
  }

consisAttitudeLists.add(finalConsisList);
consisAttitudeList.clear();

                System.out.println("now printing all contents:");

    for (ArrayList<Integer> list : consisAttitudeLists) {
            for (Integer num : list) {
                System.out.print(num + " ");
            }
            System.out.println(); // Move to the next line after printing each inner list
        }
System.out.print(consisAttitudeList.size()+" the size..");
System.out.println(consisAttitudeList.size()+" the size..");
System.out.println(finalConsisList.size()+" the size of the final list");

}

}

void OneAttitudeInConsisList() throws ParseException :
{
  Token attitude;
}
{
attitude=<STRING>
{
  String s = attitude.image.trim().toLowerCase();
  if(!initialAttitudes.containsKey(s))
    throw new ParseException("Not in initially Defined Attitudes");
  currConsisAttitude = initialAttitudes.get(s);
  consisAttitudeList.add(currConsisAttitude);
 

}
}




/*void Command1() throws ParseException :
{
    Token stringToken;
}
{
    <PRINT>
    stringToken = <STRING>
    // Execute action to print the string
    {System.out.println("Printing: " + stringToken.image);}
}*/