/* MindGRAF_Parser.java */
/* Generated By:JavaCC: Do not edit this line. MindGRAF_Parser.java */
package edu.guc.mind_graf.parser;

import edu.guc.mind_graf.context.ContextController;
import edu.guc.mind_graf.components.CustomMethod;
import edu.guc.mind_graf.nodes.IndividualNode;
import edu.guc.mind_graf.network.NetworkController;
import edu.guc.mind_graf.components.Substitutions;
import edu.guc.mind_graf.paths.IrreflexiveRestrictPath;
import edu.guc.mind_graf.paths.DomainRestrictPath;
import edu.guc.mind_graf.paths.BUnitPath;
import edu.guc.mind_graf.paths.BangPath;
import edu.guc.mind_graf.paths.OrPath;
import edu.guc.mind_graf.paths.EmptyPath;
import edu.guc.mind_graf.paths.FUnitPath;
import edu.guc.mind_graf.paths.AndPath;
import java.util.LinkedList;
import java.util.ArrayList;
import java.util.HashMap;
import java.io.StringReader;
import edu.guc.mind_graf.paths.KPlusPath;
import edu.guc.mind_graf.paths.KStarPath;
import edu.guc.mind_graf.nodes.ActNode;
import edu.guc.mind_graf.nodes.DoAllNode;
import edu.guc.mind_graf.nodes.AchieveNode;
import edu.guc.mind_graf.nodes.AttitudeNode;
import edu.guc.mind_graf.nodes.DoOneNode;
import edu.guc.mind_graf.nodes.MGIfNode;
import edu.guc.mind_graf.nodes.MGIterateNode;
import edu.guc.mind_graf.nodes.MGSequenceNode;
import edu.guc.mind_graf.set.NodeSet;
import edu.guc.mind_graf.set.Set;
import java.util.HashSet;
import java.util.Hashtable;
import edu.guc.mind_graf.paths.ConversePath;
import edu.guc.mind_graf.paths.ComposePath;
import edu.guc.mind_graf.paths.Path;
import edu.guc.mind_graf.cables.DownCable;
import edu.guc.mind_graf.cables.DownCableSet;
import edu.guc.mind_graf.caseFrames.Adjustability;
import edu.guc.mind_graf.context.Context;
import java.util.Collection;
import edu.guc.mind_graf.exceptions.NoSuchTypeException;
import edu.guc.mind_graf.mgip.reports.KnownInstance;
import edu.guc.mind_graf.exceptions.DirectCycleException;
import edu.guc.mind_graf.exceptions.NoPlansExistForTheActException;
import edu.guc.mind_graf.network.Network;
import edu.guc.mind_graf.nodes.Node;
import edu.guc.mind_graf.paths.RangeRestrictPath;
import edu.guc.mind_graf.relations.Relation;
import edu.guc.mind_graf.nodes.PropositionNode;
import edu.guc.mind_graf.set.PropositionNodeSet;
import edu.guc.mind_graf.support.Pair;

public class MindGRAF_Parser implements MindGRAF_ParserConstants {
  private static ContextController controller = new ContextController();
  private static int mode = 1;
  static boolean uvbrEnabled;
  private Network network = new Network();

  // setting the attitudes
  private static int attitudeNumber = 1;
  private static HashMap<String, Integer> initialAttitudes = new HashMap<String, Integer>();

  // setting the consistent attitudes
  private static ArrayList<ArrayList<Integer>> consisAttitudeLists = new ArrayList<ArrayList<Integer>>();
  private static ArrayList<Integer> consisAttitudeList = new ArrayList<Integer>();
  private static int currConsisAttitude;
  // setting closed under conjunction Attitudes
  private static ArrayList<Integer> finalConjList;

  // setting closed under consequence Attitudes
  private static ArrayList<Integer> finalConseqList;

  // setting telescopable Attitudes
  private static ArrayList<Integer> finalTelList;

  // automaticHandling
  private static boolean automaticHandling;

  // cacheEnabled
  private static boolean cacheEnabled;

  // mergeFN
  private static int mergeFN;
  // creation of nodes
  // private static ArrayList<Node> molecNodes = new ArrayList<Node>();
  private static HashMap<String, DownCable> allDCB = new HashMap<String, DownCable>();

  // case frames
  private static HashMap<String, ArrayList<String>> caseFrames = new HashMap<String, ArrayList<String>>();

  // semantic type
  private static ArrayList<CustomMethod> customMethods = new ArrayList<CustomMethod>();

  // forall
  private static HashMap<String, Node> varNodesForall = new HashMap<String, Node>();

  // wffs
  private static HashMap<Integer, ArrayList<String>> wffs = new HashMap<Integer, ArrayList<String>>();
  private static Integer wffCount = 1;

  // default attitude
  private static Integer defaultAttitude = 0;

  // levels
  private static boolean firstExpression = true;
  private static boolean isGrading = true;
  private static int levelsCount = 0;

  public static <K, V> HashMap<V, ArrayList<K>> groupByValue(HashMap<K, V> originalMap) {
    HashMap<V, ArrayList<K>> groupedMap = new HashMap<>();
    for (HashMap.Entry<K, V> entry : originalMap.entrySet()) {
      V value = entry.getValue();
      ArrayList<K> keys = groupedMap.get(value);
      if (keys == null) {
        keys = new ArrayList<>();
        groupedMap.put(value, keys);
      }
      keys.add(entry.getKey());
    }
    return groupedMap;
  }

  public static void ResetGrading() {
    isGrading = true;
    firstExpression = true;
    levelsCount = 0;
  }

  public static void printHyps(Pair<PropositionNodeSet, PropositionNodeSet>[] hyps) {
    for (Pair<PropositionNodeSet, PropositionNodeSet> pair : hyps) {
      Collection<Node> firstSet = pair.getFirst().getNodes();
      Collection<Node> secondSet = pair.getSecond().getNodes();
      CLI.print("Ungraded Nodes:");
      for (Node n : firstSet)
        CLI.print(n.toString());

      CLI.print("Graded Nodes:");
      for (Node n : secondSet)
        CLI.print(n.toString());

    }
  }

  public static void GetAllHypsInContextAttitude(String CName, String attitude, boolean c, boolean a) {
    Pair<PropositionNodeSet, PropositionNodeSet>[] hyps;
    try {
      if (c && a) {
        if (!controller.getContextSet().getSet().containsKey(CName)) {
          CLI.print("No such Context.");
          return;
        }
        if (!controller.getAttitudes().getSet().containsKey(attitude)) {
          CLI.print("No such Attitude.");
          return;
        }
        Integer attNum = controller.getAttitudeNumber(attitude);
        hyps = controller.getContext(CName).getHypotheses().get(attNum);
        CLI.print("Hypotheses in Context " + CName + " Attitude " + attitude + ":");
        printHyps(hyps);
        return;
      }
      if (c) {
        if (!controller.getContextSet().getSet().containsKey(CName)) {
          CLI.print("No such Context.");
          return;
        }
        hyps = controller.getContext(CName).getHypotheses()
            .get(defaultAttitude);
        printHyps(hyps);
        CLI.print("Hypotheses in Context " + CName + " Attitude " + controller.getAttitudeName(defaultAttitude) + ":");
        return;
      }
      if (a) {
        if (!controller.getAttitudes().getSet().containsKey(attitude)) {
          CLI.print("No such Attitude.");
          return;
        }
        try {
          hyps = controller.getContext(controller.getCurrContextName()).getHypotheses()
              .get(controller.getAttitudeNumber(attitude));
          CLI.print("Hypotheses in Context " + controller.getCurrContextName() + " Attitude " + attitude + ":");
          printHyps(hyps);

        } catch (NullPointerException e) {
          CLI.print("Set Current Context First.");
          return;
        }
      }
      try {
        hyps = controller.getContext(controller.getCurrContextName()).getHypotheses().get(defaultAttitude);
        CLI.print("Hypotheses in Context " + controller.getCurrContextName() + " Attitude "
            + controller.getAttitudeName(defaultAttitude) + ":");
        printHyps(hyps);

      } catch (NullPointerException e) {
        CLI.print("Set Current Context First.");
        return;
      }
    } catch (Exception e) {
      // TODO Auto-generated catch block
      e.printStackTrace();
    }
  }

  public static void removeFromContext(String CName, String attitude, boolean a, boolean c, PropositionNode propNode) {
    try {
      if (c && a) {
        if (!controller.getContextSet().getSet().containsKey(CName)) {
          CLI.print("No such Context.");
          return;
        }
        if (!controller.getAttitudes().getSet().containsKey(attitude)) {
          CLI.print("No such Attitude.");
          return;
        }
        controller.removeHypothesisFromContext(CName, levelsCount, controller.getAttitudeNumber(attitude),
            propNode.getId());
        CLI.print("Hypothesis Removed.");

        return;
      }
      if (c) {
        if (!controller.getContextSet().getSet().containsKey(CName)) {
          CLI.print("No such Context.");
          return;
        }
        controller.removeHypothesisFromContext(CName, levelsCount, defaultAttitude, propNode.getId());
        CLI.print("Hypothesis Removed.");

        return;
      }
      if (a) {
        if (!controller.getAttitudes().getSet().containsKey(attitude)) {
          CLI.print("No such Attitude.");
          return;
        }
        try {
          controller.removeHypothesisFromContext(controller.getCurrContextName(), levelsCount,
              controller.getAttitudeNumber(attitude), propNode.getId());
          CLI.print("Hypothesis Removed.");

        } catch (NullPointerException e) {
          CLI.print("Set Current Context First.");
          return;
        }
      }
      try {
        controller.removeHypothesisFromContext(controller.getCurrContextName(), levelsCount, defaultAttitude,
            propNode.getId());
        CLI.print("Hypothesis Removed.");

      } catch (NullPointerException e) {
        CLI.print("Set Current Context First.");
        return;
      }
    } catch (Exception e) {
      // TODO Auto-generated catch block
      e.printStackTrace();
    }
  }

  public static void addToContext(String CName, String attitude, boolean a, boolean c, PropositionNode propNode) {
    try {
      if (c && a) {
        if (!controller.getContextSet().getSet().containsKey(CName)) {
          CLI.print("No such Context.");
          return;
        }
        if (!controller.getAttitudes().getSet().containsKey(attitude)) {
          CLI.print("No such Attitude.");
          return;
        }
        controller.addHypothesisToContext(CName, levelsCount, controller.getAttitudeNumber(attitude), propNode);

        return;

      }
      if (c) {
        if (!controller.getContextSet().getSet().containsKey(CName)) {
          CLI.print("No such Context.");
          return;
        }
        controller.addHypothesisToContext(CName, levelsCount, defaultAttitude, propNode);

        return;
      }
      if (a) {
        if (!controller.getAttitudes().getSet().containsKey(attitude)) {
          CLI.print("No such Attitude.");
          return;
        }
        try {
          controller.addHypothesisToContext(controller.getCurrContextName(), levelsCount,
              controller.getAttitudeNumber(attitude), propNode);

        } catch (NullPointerException e) {
          CLI.print("Set Current Context First.");
          return;
        }
      }
      try {
        controller.addHypothesisToContext(controller.getCurrContextName(), levelsCount, defaultAttitude, propNode);

      } catch (NullPointerException e) {
        CLI.print("Set Current Context First.");
        return;
      }
    } catch (Exception e) {
      // TODO Auto-generated catch block
      e.printStackTrace();
    }
  }

  @SuppressWarnings("static-access")
  public static void removeDuplicates(ArrayList<String> list) {
    HashSet<String> set = new HashSet<>();
    for (int i = 0; i < list.size(); i++) {
      String str = list.get(i);
      if (!set.add(str)) { // If adding the string returns false, it's a duplicate
        list.remove(i); // Remove the duplicate string
        i--; // Decrement i to adjust for the removed element
      }
    }
  }

  public static void bInference(PropositionNode propNode, boolean c, boolean a, String CName, String attitude) {
    try {
      if (c && a) {
        if (!controller.getContextSet().getSet().containsKey(CName)) {
          CLI.print("No such Context.");
          {
            if ("" != null)
              return;
          }
        }
        if (!controller.getAttitudes().getSet().containsKey(attitude)) {
          CLI.print("No such Attitude.");
          return;
        }
        propNode.deduce(CName, controller.getAttitudeNumber(attitude));
        return;
      }
      if (c) {
        if (!controller.getContextSet().getSet().containsKey(CName)) {
          CLI.print("No such Context.");
          return;
        }
        propNode.deduce(CName, defaultAttitude);

        return;

      }
      if (a) {
        if (!controller.getAttitudes().getSet().containsKey(attitude)) {
          CLI.print("No such Attitude.");

          return;

        }
        try {
          propNode.deduce(controller.getCurrContextName(), controller.getAttitudeNumber(attitude));
        } catch (NullPointerException e) {
          CLI.print("Set Current Context First.");
          return;
        }
      }
      try {
        propNode.deduce(controller.getCurrContextName(), defaultAttitude);
      } catch (NullPointerException e) {
        CLI.print("Set Current Context First.");
        return;
      }
    } catch (NoSuchTypeException | NoPlansExistForTheActException | DirectCycleException e) {
      // TODO Auto-generated catch block
      e.printStackTrace();
    }
  }

  public static int indexOfList(ArrayList<ArrayList<String>> listOfLists, ArrayList<String> listToAdd) {
    // Iterate over the listOfLists and compare each inner list with listToAdd
    for (int i = 0; i < listOfLists.size(); i++) {
      ArrayList<String> currentList = listOfLists.get(i);
      if (areListsEqual(currentList, listToAdd)) {
        return i; // If found, return the index
      }
    }
    return -1; // If not found, return -1
  }

  private static boolean areListsEqual(ArrayList<String> list1, ArrayList<String> list2) {
    // Check if the lists have the same size
    if (list1.size() != list2.size()) {
      return false;
    }
    // Check if the elements in list1 exist in list2
    for (String element : list1) {
      if (!list2.contains(element)) {
        return false;
      }
    }
    // Check if the elements in list2 exist in list1
    for (String element : list2) {
      if (!list1.contains(element)) {
        return false;
      }
    }
    // If all elements are found in both lists, they are equal
    return true;
  }

  public Node compareMolecularNode(DownCableSet dcs) {
    Node returnNode = null;
    for (Node nn : network.getNodes().values()) {
      DownCableSet downc = nn.getDownCableSet();
      if (downc != null) {
        String key = downc.getMolecularSetKey();
        if (key.equals(dcs.getMolecularSetKey())) {
          returnNode = nn;
          Collection<DownCable> dcCollection = downc.getValues();
          for (DownCable d : dcCollection) {
            String relName = d.getRelation().getName();
            ArrayList<String> firstNs = d.getNodeSet().getNames();
            ArrayList<String> ns = dcs.get(relName).getNodeSet().getNames();
            if (!firstNs.equals(ns))
              return null;
          }
          break;
        }
      }
    }
    return returnNode;

  }

  public static void fInference(PropositionNode propNode, boolean c, boolean a, String CName, String attitude) {
    try {
      if (c && a) {
        if (!controller.getContextSet().getSet().containsKey(CName)) {
          CLI.print("No such Context.");
          {
            if ("" != null)
              return;
          }
        }
        if (!controller.getAttitudes().getSet().containsKey(attitude)) {
          CLI.print("No such Attitude.");
          return;
        }
        propNode.add(CName, controller.getAttitudeNumber(attitude));
        return;
      }
      if (c) {
        if (!controller.getContextSet().getSet().containsKey(CName)) {
          CLI.print("No such Context.");
          return;
        }
        propNode.add(CName, defaultAttitude);

        return;

      }
      if (a) {
        if (!controller.getAttitudes().getSet().containsKey(attitude)) {
          CLI.print("No such Attitude.");

          return;

        }
        try {
          propNode.add(controller.getCurrContextName(), controller.getAttitudeNumber(attitude));
        } catch (NullPointerException e) {
          CLI.print("Set Current Context First.");
          return;
        }
      }
      try {
        propNode.add(controller.getCurrContextName(), defaultAttitude);
      } catch (NullPointerException e) {
        CLI.print("Set Current Context First.");
        return;
      }
    } catch (NoSuchTypeException | NoPlansExistForTheActException | DirectCycleException e) {
      // TODO Auto-generated catch block
      e.printStackTrace();
    }
  }

  public static Integer isSupported(PropositionNode propNode, boolean c, boolean a, String CName, String attitude) {
    try {
      if (c && a) {
        if (!controller.getContextSet().getSet().containsKey(CName)) {
          CLI.print("No such Context.");
          return null;

        }
        if (!controller.getAttitudes().getSet().containsKey(attitude)) {
          CLI.print("No such Attitude.");
          return null;
        }

        return propNode.supported(CName, controller.getAttitudeNumber(attitude), levelsCount) ? 1 : 0;
      }
      if (c) {
        if (!controller.getContextSet().getSet().containsKey(CName)) {
          CLI.print("No such Context.");
          return null;
        }
        return propNode.supported(CName, defaultAttitude, levelsCount) ? 1 : 0;

      }
      if (a) {
        if (!controller.getAttitudes().getSet().containsKey(attitude)) {
          CLI.print("No such Attitude.");

          return null;

        }
        try {
          return propNode.supported(controller.getCurrContextName(), controller.getAttitudeNumber(attitude),
              levelsCount) ? 1 : 0;
        } catch (NullPointerException e) {
          CLI.print("Set Current Context First.");
          return null;
        }
      }
      try {
        return propNode.supported(controller.getCurrContextName(), defaultAttitude,
            levelsCount) ? 1 : 0;
      } catch (NullPointerException e) {
        CLI.print("Set Current Context First.");
        return null;
      }
    } catch (Exception e) {
      // TODO Auto-generated catch block
      e.printStackTrace();
      return null;
    }
  }

  public static void main(String[] args) throws ParseException {
    // Instantiate the parser
    MindGRAF_Parser parser = new MindGRAF_Parser(System.in);
    /*
     * try {
     * // Start parsing
     * parser.Start();
     * 
     * System.out.println("Parsing successful!");
     * } catch (ParseException e) {
     * // Handle parsing errors
     * System.err.println("Parsing failed: " + e.getMessage());
     * }
     */
  }

  // Define the grammar
  final public

      Node Expression() throws ParseException, ParseException {
    Node result = null;
    switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
      case PREDICATE_NAME_BRACKET: {
        result = Predicate();
        break;
      }
      case ANDOR_THRESH: {
        result = AndOrThreshExpression(false);
        break;
      }
      case 32: {
        result = OrAndEntailment(false);
        break;
      }
      case QUANTIFIER: {
        result = forall();
        break;
      }
      case WHENDO_DOIF: {
        result = WhenIfDo();
        break;
      }
      case 26: {
        result = gradedProp();
        break;
      }
      case 25: {
        result = negatedProp();
        break;
      }
      default:
        jj_la1[0] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
    }
    {
      if ("" != null)
        return result;
    }
    throw new Error("Missing return statement in function");
  }

  final public Node andOrThreshEnt() throws ParseException, ParseException {
    Node arg;
    switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
      case ANDOR_THRESH: {
        arg = AndOrThreshExpression(true);
        break;
      }
      case 32: {
        arg = OrAndEntailment(true);
        break;
      }
      default:
        jj_la1[1] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
    }
    {
      if ("" != null)
        return arg;
    }
    throw new Error("Missing return statement in function");
  }

  final public Node negatedAndOrThreshEnt() throws ParseException, ParseException {
    Node node = null;
    jj_consume_token(25);
    node = andOrThreshEnt();
    Node negatedNode = null;
    try {
      negatedNode = node.createNegation(node);
    } catch (NoSuchTypeException e) {
      // TODO Auto-generated catch block
      e.printStackTrace();
    }
    {
      if ("" != null)
        return negatedNode;
    }
    throw new Error("Missing return statement in function");
  }

  final public Node gradedAndOrThreshEnt() throws ParseException {
    Node node = null;
    String gradeValue = null;
    jj_consume_token(26);
    node = andOrThreshEnt();
    jj_consume_token(27);
    gradeValue = jj_consume_token(NUMBER).image;
    jj_consume_token(28);
    gradeValue = gradeValue.trim();
    // Relations
    Relation grade = network.getRelations().get("grade");
    Relation prop = network.getRelations().get("prop");

    // nodes
    Node gradeNode = null;
    Node molecNode = null;
    try {
      gradeNode = network.createNode(gradeValue, "individualnode");
      // cables
      DownCable gradeDC = new DownCable(grade, new NodeSet(gradeNode));
      DownCable propDC = new DownCable(prop, new NodeSet(node));
      DownCableSet alldcs = new DownCableSet(gradeDC, propDC);
      Node shouldCreate = compareMolecularNode(alldcs);
      if (shouldCreate == null)
        molecNode = network.createNode("propositionnode", alldcs);
      else
        molecNode = shouldCreate;
    } catch (NoSuchTypeException e) {
      // TODO Auto-generated catch block
      e.printStackTrace();
    }
    {
      if ("" != null)
        return molecNode;
    }
    throw new Error("Missing return statement in function");
  }

  final public Node ForallExpressionList() throws ParseException, ParseException {
    Node arg;
    switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
      case ANDOR_THRESH:
      case 32: {
        arg = andOrThreshEnt();
        break;
      }
      case 26: {
        arg = gradedAndOrThreshEnt();
        break;
      }
      case 25: {
        arg = negatedAndOrThreshEnt();
        {
          if ("" != null)
            return arg;
        }
        break;
      }
      default:
        jj_la1[2] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public Node forall() throws ParseException, ParseException {
    firstExpression = false;
    Node arg = null;
    ArrayList<Node> varNodes = new ArrayList<Node>();
    isGrading = false;
    jj_consume_token(QUANTIFIER);
    varNodes = variableNodes();
    HashMap<String, Node> nodeSet = new HashMap<String, Node>();
    for (Node n : varNodes)
      nodeSet.put(n.getName(), n);

    varNodesForall = nodeSet;
    jj_consume_token(29);
    jj_consume_token(30);
    arg = ForallExpressionList();
    jj_consume_token(29);
    {
      if ("" != null)
        return arg;
    }
    throw new Error("Missing return statement in function");
  }

  final public ArrayList<Node> variableNodes() throws ParseException, ParseException {
    Node varNode = null;
    String var = null;
    ArrayList<Node> varNodes = new ArrayList<Node>();
    var = jj_consume_token(STRING).image;
    String s = var.trim().toLowerCase();
    try {
      varNodes.add(network.createVariableNode(s, "propositionnode"));
    } catch (NoSuchTypeException e) {
      // TODO Auto-generated catch block
      e.printStackTrace();
    }
    label_1: while (true) {
      switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
        case 27: {
          ;
          break;
        }
        default:
          jj_la1[3] = jj_gen;
          break label_1;
      }
      jj_consume_token(27);
      var = jj_consume_token(STRING).image;
      String ss = var.trim().toLowerCase();
      try {
        varNodes.add(network.createVariableNode(ss, "propositionnode"));
      } catch (NoSuchTypeException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
      }
    }
    {
      if ("" != null)
        return varNodes;
    }
    throw new Error("Missing return statement in function");
  }

  final public Node WhenIfDo() throws ParseException, ParseException {
    Node prop = null;
    Node actNode = null;
    String attitude;
    String ruleType;
    firstExpression = false;
    isGrading = false;
    ruleType = jj_consume_token(WHENDO_DOIF).image;
    prop = Expression();
    jj_consume_token(27);
    attitude = jj_consume_token(STRING).image;
    jj_consume_token(28);
    jj_consume_token(31);
    jj_consume_token(32);
    actNode = Act();
    jj_consume_token(28);
    ruleType = ruleType.trim().toLowerCase();
    ruleType = ruleType.substring(0, ruleType.length() - 1);
    attitude = attitude.trim().toLowerCase();
    Integer attNum = controller.getAttitudeNumber(attitude);
    if (attNum == null) {
      if (true)
        throw new ParseException("No such attitude.");
    }

    Relation doRel = network.getRelations().get("do");
    DownCable doDC = new DownCable(doRel, new NodeSet(actNode));
    if (ruleType.equals("whendo")) {
      // creating when do relations
      Relation whenRel = network.createRelation(attNum + "-when", "propositionnode", Adjustability.NONE, 0);
      // downcable
      DownCable whenDC = new DownCable(whenRel, new NodeSet(prop));

      DownCableSet whenDoDC = new DownCableSet(whenDC, doDC);
      // creating whenDo Rule Node
      Node shouldCreate = compareMolecularNode(whenDoDC);
      Node whenDoNode = null;
      try {
        if (shouldCreate == null)
          whenDoNode = network.createNode("propositionnode", whenDoDC);
        else
          whenDoNode = shouldCreate;
      } catch (NoSuchTypeException e) {
        // TODO: handle exception
      }
      {
        if ("" != null)
          return whenDoNode;
      }

    } else {
      // creating do if relations
      Relation ifRel = network.createRelation(attNum + "-if", "propositionnode", Adjustability.NONE, 0);

      // downcable
      DownCable ifDC = new DownCable(ifRel, new NodeSet(prop));

      DownCableSet ifDoDC = new DownCableSet(ifDC, doDC);
      // creating whenDo Rule Node
      Node shouldCreate = compareMolecularNode(ifDoDC);
      Node ifDoNode = null;
      try {
        if (shouldCreate == null)
          ifDoNode = network.createNode("propositionnode", ifDoDC);
        else
          ifDoNode = shouldCreate;
      } catch (NoSuchTypeException e) {
        // TODO: handle exception
      }
      {
        if ("" != null)
          return ifDoNode;
      }

    }
    throw new Error("Missing return statement in function");
  }

  final public ActNode Act() throws ParseException, ParseException {
    Node act = null;
    switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
      case 33: {
        act = mgSequence();
        break;
      }
      case 49: {
        act = Attitude();
        break;
      }
      case 50: {
        act = Achieve();
        break;
      }
      case 51: {
        act = DoOne();
        break;
      }
      case 52: {
        act = DoAll();
        break;
      }
      case 53: {
        act = GuardedAct();
        break;
      }
      case 54: {
        act = MGIF();
        break;
      }
      case 55: {
        act = SNIterate();
        break;
      }
      default:
        jj_la1[4] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
    }
    {
      if ("" != null)
        return (ActNode) act;
    }
    {
      if (true)
        throw new ParseException("No valid action found.");
    }
    throw new Error("Missing return statement in function");
  }

  final public MGSequenceNode mgSequence() throws ParseException, ParseException {
    Node oneActNode = null;
    ArrayList<Node> allNodes = new ArrayList<Node>();
    jj_consume_token(33);
    oneActNode = Act();
    allNodes.add(oneActNode);
    label_2: while (true) {
      switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
        case 27: {
          ;
          break;
        }
        default:
          jj_la1[5] = jj_gen;
          break label_2;
      }
      jj_consume_token(27);
      oneActNode = Act();
      allNodes.add(oneActNode);
    }
    jj_consume_token(28);
    // relations

    IndividualNode snSeqIndividual = null;
    MGSequenceNode snsequenceNode = null;
    // relations and Dcs
    HashMap<String, DownCable> allDCs = new HashMap<String, DownCable>();
    for (int i = 0; i < allNodes.size(); i++) {
      Relation rel = null;
      if (network.getRelations().containsKey("obj" + (i + 1)))
        rel = network.getRelations().get("obj" + (i + 1));
      else
        rel = network.createRelation("obj" + i, "actnode", Adjustability.NONE, i);
      DownCable dc = new DownCable(rel, new NodeSet(allNodes.get(i)));
      allDCs.put(rel.getName(), dc);
    }
    Relation action = network.getRelations().get("action");
    DownCable actionDC = new DownCable(action, new NodeSet(snSeqIndividual));
    allDCs.put(action.getName(), actionDC);
    DownCableSet dcSet = new DownCableSet(allDCs);
    try {
      // individual node
      if (network.getBaseNodes().containsKey("mgsequence"))
        snSeqIndividual = (IndividualNode) network.getBaseNodes().get("mgsequence");
      else
        snSeqIndividual = (IndividualNode) network.createNode("mgsequence", "individualnode");

      // snsequence act node creation
      Node shouldCreate = compareMolecularNode(dcSet);
      if (shouldCreate == null)
        snsequenceNode = (MGSequenceNode) network.createNode("mgsequencenode", dcSet);
      else
        snsequenceNode = (MGSequenceNode) shouldCreate;
      CLI.print("MGSequence Act Node Created.");
      {
        if ("" != null)
          return snsequenceNode;
      }

    } catch (NoSuchTypeException e) {
      // TODO Auto-generated catch block
      e.printStackTrace();
    }
    throw new Error("Missing return statement in function");
  }

  final public Relation Relation() throws ParseException, ParseException {
    String name = null;
    String type = null;
    String adjust = null;
    String limit;
    jj_consume_token(34);
    name = jj_consume_token(STRING).image;
    jj_consume_token(27);
    type = jj_consume_token(STRING).image;
    jj_consume_token(27);
    adjust = jj_consume_token(ADJUST).image;
    jj_consume_token(27);
    limit = jj_consume_token(NUMBER).image;
    jj_consume_token(28);
    name = name.trim().toLowerCase();
    type = type.trim().toLowerCase();
    adjust = adjust.trim();
    Relation relation = Network.createRelation(name, type, adjust.equals("expand") ? Adjustability.EXPAND
        : adjust.equals("reduce") ? Adjustability.REDUCE : Adjustability.NONE, Integer.parseInt(limit));
    {
      if ("" != null)
        return relation;
    }
    throw new Error("Missing return statement in function");
  }

  final public Path FUnit() throws ParseException, ParseException {
    Relation relation = null;
    String relationName = null;
    jj_consume_token(35);
    switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
      case 34: {
        relation = Relation();
        break;
      }
      case STRING: {
        relationName = jj_consume_token(STRING).image;
        break;
      }
      default:
        jj_la1[6] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
    }
    jj_consume_token(29);
    if (relationName == null) {
      FUnitPath fUnit = new FUnitPath(relation);
      {
        if ("" != null)
          return fUnit;
      }
    }
    relationName = relationName.trim().toLowerCase();
    if (!Network.getRelations().containsKey(relationName)) {
      if (true)
        throw new ParseException("No Such Relation.");
    }

    relation = Network.getRelations().get(relationName);
    FUnitPath fUnit = new FUnitPath(relation);
    {
      if ("" != null)
        return fUnit;
    }
    throw new Error("Missing return statement in function");
  }

  final public Path BUnit() throws ParseException, ParseException {
    Relation relation = null;
    String relationName = null;
    jj_consume_token(36);
    switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
      case 34: {
        relation = Relation();
        break;
      }
      case STRING: {
        relationName = jj_consume_token(STRING).image;
        break;
      }
      default:
        jj_la1[7] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
    }
    jj_consume_token(29);
    if (relationName == null) {
      BUnitPath bUnit = new BUnitPath(relation);
      {
        if ("" != null)
          return bUnit;
      }
    }
    relationName = relationName.trim().toLowerCase();
    if (!Network.getRelations().containsKey(relationName)) {
      if (true)
        throw new ParseException("No Such Relation.");
    }

    relation = Network.getRelations().get(relationName);
    BUnitPath bUnit = new BUnitPath(relation);
    {
      if ("" != null)
        return bUnit;
    }
    throw new Error("Missing return statement in function");
  }

  final public Path ComposePath() throws ParseException, ParseException {
    Path onePath = null;
    LinkedList<Path> allPaths = new LinkedList<Path>();
    jj_consume_token(37);
    onePath = Path();
    allPaths.add(onePath);
    label_3: while (true) {
      switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
        case 27: {
          ;
          break;
        }
        default:
          jj_la1[8] = jj_gen;
          break label_3;
      }
      jj_consume_token(27);
      onePath = Path();
      allPaths.add(onePath);
    }
    jj_consume_token(29);
    ComposePath composePath = new ComposePath(allPaths);
    {
      if ("" != null)
        return composePath;
    }
    throw new Error("Missing return statement in function");
  }

  final public Path ConversePath() throws ParseException, ParseException {
    Path path = null;
    jj_consume_token(38);
    path = Path();
    jj_consume_token(29);
    ConversePath conversePath = new ConversePath(path);
    {
      if ("" != null)
        return conversePath;
    }
    throw new Error("Missing return statement in function");
  }

  final public Path KStar() throws ParseException, ParseException {
    Path path = null;
    jj_consume_token(39);
    path = Path();
    jj_consume_token(29);
    KStarPath kstar = new KStarPath(path);
    {
      if ("" != null)
        return kstar;
    }
    throw new Error("Missing return statement in function");
  }

  final public Path KPlus() throws ParseException, ParseException {
    Path path = null;
    jj_consume_token(40);
    path = Path();
    jj_consume_token(29);
    KPlusPath kplus = new KPlusPath(path);
    {
      if ("" != null)
        return kplus;
    }
    throw new Error("Missing return statement in function");
  }

  final public Path OrPath() throws ParseException, ParseException {
    Path onePath = null;
    LinkedList<Path> allPaths = new LinkedList<Path>();
    jj_consume_token(41);
    onePath = Path();
    allPaths.add(onePath);
    label_4: while (true) {
      switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
        case 27: {
          ;
          break;
        }
        default:
          jj_la1[9] = jj_gen;
          break label_4;
      }
      jj_consume_token(27);
      onePath = Path();
      allPaths.add(onePath);
    }
    jj_consume_token(29);
    OrPath orPath = new OrPath(allPaths);
    {
      if ("" != null)
        return orPath;
    }
    throw new Error("Missing return statement in function");
  }

  final public Path AndPath() throws ParseException, ParseException {
    Path onePath = null;
    LinkedList<Path> allPaths = new LinkedList<Path>();
    jj_consume_token(42);
    onePath = Path();
    allPaths.add(onePath);
    label_5: while (true) {
      switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
        case 27: {
          ;
          break;
        }
        default:
          jj_la1[10] = jj_gen;
          break label_5;
      }
      jj_consume_token(27);
      onePath = Path();
      allPaths.add(onePath);
    }
    jj_consume_token(29);
    AndPath andPath = new AndPath(allPaths);
    {
      if ("" != null)
        return andPath;
    }
    throw new Error("Missing return statement in function");
  }

  final public Path IrreflexiveRestrictPath() throws ParseException, ParseException {
    Path path = null;
    jj_consume_token(43);
    path = Path();
    jj_consume_token(29);
    IrreflexiveRestrictPath irrefPath = new IrreflexiveRestrictPath(path);
    {
      if ("" != null)
        return irrefPath;
    }
    throw new Error("Missing return statement in function");
  }

  final public Path DomainRestrictPath() throws ParseException, ParseException {
    Path p1 = null;
    Path p2 = null;
    Node node = null;
    jj_consume_token(44);
    Path();
    jj_consume_token(27);
    Path();
    jj_consume_token(27);
    Expression();
    jj_consume_token(29);
    DomainRestrictPath domainPath = new DomainRestrictPath(p1, p2, node);
    {
      if ("" != null)
        return domainPath;
    }
    throw new Error("Missing return statement in function");
  }

  final public Path RangeRestrictPath() throws ParseException, ParseException {
    Path p1 = null;
    Path p2 = null;
    Node node = null;
    jj_consume_token(45);
    Path();
    jj_consume_token(27);
    Path();
    jj_consume_token(27);
    Expression();
    jj_consume_token(29);
    RangeRestrictPath rangePath = new RangeRestrictPath(p1, p2, node);
    {
      if ("" != null)
        return rangePath;
    }
    throw new Error("Missing return statement in function");
  }

  final public Path BangPath() throws ParseException, ParseException {
    jj_consume_token(46);
    BangPath bangPath = new BangPath();
    {
      if ("" != null)
        return bangPath;
    }
    throw new Error("Missing return statement in function");
  }

  final public Path EmptyPath() throws ParseException, ParseException {
    jj_consume_token(47);
    EmptyPath emptyPath = new EmptyPath();
    {
      if ("" != null)
        return emptyPath;
    }
    throw new Error("Missing return statement in function");
  }

  final public Path Path() throws ParseException, ParseException {
    Path path = null;
    switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
      case 35: {
        path = FUnit();
        {
          if ("" != null)
            return path;
        }
        break;
      }
      case 36: {
        path = BUnit();
        {
          if ("" != null)
            return path;
        }
        break;
      }
      case 41: {
        path = OrPath();
        {
          if ("" != null)
            return path;
        }
        break;
      }
      case 42: {
        path = AndPath();
        {
          if ("" != null)
            return path;
        }
        break;
      }
      case 46: {
        path = BangPath();
        {
          if ("" != null)
            return path;
        }
        break;
      }
      case 47: {
        path = EmptyPath();
        {
          if ("" != null)
            return path;
        }
        break;
      }
      case 40: {
        path = KPlus();
        {
          if ("" != null)
            return path;
        }
        break;
      }
      case 39: {
        path = KStar();
        {
          if ("" != null)
            return path;
        }
        break;
      }
      case 37: {
        path = ComposePath();
        {
          if ("" != null)
            return path;
        }
        break;
      }
      case 45: {
        path = RangeRestrictPath();
        {
          if ("" != null)
            return path;
        }
        break;
      }
      case 44: {
        path = DomainRestrictPath();
        {
          if ("" != null)
            return path;
        }
        break;
      }
      case 43: {
        path = IrreflexiveRestrictPath();
        {
          if ("" != null)
            return path;
        }
        break;
      }
      case 38: {
        path = ConversePath();
        {
          if ("" != null)
            return path;
        }
        break;
      }
      default:
        jj_la1[11] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public void definePath() throws ParseException, ParseException {
    Path path = null;
    Relation relation = null;
    String relationName = null;
    jj_consume_token(48);
    switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
      case 34: {
        relation = Relation();
        break;
      }
      case STRING: {
        relationName = jj_consume_token(STRING).image;
        break;
      }
      default:
        jj_la1[12] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
    }
    path = Path();
    if (relationName == null) {
      relation.setPath(path);
      CLI.print("Path '" + relation.getPath().toString() + "' is Defined for relation " + relation.getName() + ".");

      {
        if ("" != null)
          return;
      }
    }
    relationName = relationName.trim().toLowerCase();
    if (!Network.getRelations().containsKey(relationName)) {
      if (true)
        throw new ParseException("No Such Relation.");
    }

    relation = Network.getRelations().get(relationName);
    relation.setPath(path);
    CLI.print(
        "Path '" + relation.getPath().toString() + "' is Defined for relation " + "'" + relation.getName() + "'" + ".");
  }

  final public AttitudeNode Attitude() throws ParseException, ParseException {
    Node prop = null;
    jj_consume_token(49);
    prop = Expression();
    jj_consume_token(28);
    ResetGrading();
    // relations
    Relation action = network.getRelations().get("action");
    Relation obj = network.getRelations().get("obj");

    // attitude indiv node
    IndividualNode attitudeIndividual = null;
    AttitudeNode attitudeActNode = null;
    try {
      if (network.getBaseNodes().containsKey("attitude"))
        attitudeIndividual = (IndividualNode) network.getBaseNodes().get("attitude");
      else
        attitudeIndividual = (IndividualNode) network.createNode("attitude", "individualnode");
      // cables
      DownCable objDC = new DownCable(obj, new NodeSet(prop));
      DownCable actionDC = new DownCable(action, new NodeSet(attitudeIndividual));
      DownCableSet alldcs = new DownCableSet(objDC, actionDC);
      // attitude act node
      Node shouldCreate = compareMolecularNode(alldcs);
      if (shouldCreate == null)
        attitudeActNode = (AttitudeNode) network.createNode("actnode", new DownCableSet(objDC, actionDC));
      else
        attitudeActNode = (AttitudeNode) shouldCreate;
      CLI.print("Attitude Act Node Created.");
      {
        if ("" != null)
          return attitudeActNode;
      }

    } catch (NoSuchTypeException e) {
      // TODO Auto-generated catch block
      e.printStackTrace();
    }
    throw new Error("Missing return statement in function");
  }

  final public AchieveNode Achieve() throws ParseException, ParseException {
    Node prop = null;
    jj_consume_token(50);
    prop = Expression();
    jj_consume_token(28);
    ResetGrading();
    // relations
    Relation action = network.getRelations().get("action");
    Relation obj = network.getRelations().get("obj");

    // believe indiv node
    IndividualNode achieveIndividual = null;
    AchieveNode achieveActNode = null;
    try {
      if (network.getBaseNodes().containsKey("achieve"))
        achieveIndividual = (IndividualNode) network.getBaseNodes().get("achieve");
      else
        achieveIndividual = (IndividualNode) network.createNode("achieve", "individualnode");
      // cables
      DownCable objDC = new DownCable(obj, new NodeSet(prop));
      DownCable actionDC = new DownCable(action, new NodeSet(achieveIndividual));
      DownCableSet alldcs = new DownCableSet(objDC, actionDC);
      // achieve act node
      Node shouldCreate = compareMolecularNode(alldcs);
      if (shouldCreate == null)
        achieveActNode = (AchieveNode) network.createNode("actnode", new DownCableSet(objDC, actionDC));
      else
        achieveActNode = (AchieveNode) shouldCreate;
      CLI.print("Achieve Act Node Created.");

      {
        if ("" != null)
          return achieveActNode;
      }
    } catch (NoSuchTypeException e) {
      // TODO Auto-generated catch block
      e.printStackTrace();
    }
    throw new Error("Missing return statement in function");
  }

  final public DoOneNode DoOne() throws ParseException, ParseException {
    HashMap<String, Node> hashedNodes = new HashMap<String, Node>();
    Node oneAct;
    jj_consume_token(51);
    oneAct = Act();
    hashedNodes.put(oneAct.getName(), oneAct);
    label_6: while (true) {
      switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
        case 27: {
          ;
          break;
        }
        default:
          jj_la1[13] = jj_gen;
          break label_6;
      }
      jj_consume_token(27);
      oneAct = Act();
      hashedNodes.put(oneAct.getName(), oneAct);
    }
    jj_consume_token(28);
    // relations
    Relation action = network.getRelations().get("action");
    Relation obj = network.getRelations().get("obj");

    // dooneIndividual
    IndividualNode doOneIndiv = null;
    DoOneNode doOneActNode = null;
    try {
      if (network.getBaseNodes().containsKey("doone"))
        doOneIndiv = (IndividualNode) network.getBaseNodes().get("doone");
      else
        doOneIndiv = (IndividualNode) network.createNode("doone", "individualnode"); // cables
      DownCable actionDC = new DownCable(action, new NodeSet(doOneIndiv));
      DownCable objDC = new DownCable(obj, new NodeSet(hashedNodes));
      DownCableSet allCables = new DownCableSet(actionDC, objDC);
      Node shouldCreate = compareMolecularNode(allCables);
      if (shouldCreate == null)
        doOneActNode = (DoOneNode) network.createNode("actnode", allCables);
      else
        doOneActNode = (DoOneNode) shouldCreate;
      CLI.print("DoOne Act Node Created.");
      {
        if ("" != null)
          return doOneActNode;
      }

    } catch (NoSuchTypeException e) {
      // TODO Auto-generated catch block
      e.printStackTrace();
    }
    throw new Error("Missing return statement in function");
  }

  final public DoAllNode DoAll() throws ParseException, ParseException {
    HashMap<String, Node> hashedNodes = new HashMap<String, Node>();
    ActNode oneAct;
    jj_consume_token(52);
    oneAct = Act();
    hashedNodes.put(oneAct.getName(), oneAct);
    label_7: while (true) {
      switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
        case 27: {
          ;
          break;
        }
        default:
          jj_la1[14] = jj_gen;
          break label_7;
      }
      jj_consume_token(27);
      oneAct = Act();
      hashedNodes.put(oneAct.getName(), oneAct);
    }
    jj_consume_token(28);
    // relations
    Relation action = network.getRelations().get("action");
    Relation obj = network.getRelations().get("obj");

    // doAllIndividual
    IndividualNode doAllIndiv = null;
    DoAllNode doAllActNode = null;
    try {
      if (network.getBaseNodes().containsKey("doall"))
        doAllIndiv = (IndividualNode) network.getBaseNodes().get("doall");
      else
        doAllIndiv = (IndividualNode) network.createNode("doall", "individualnode");
      // cables
      DownCable actionDC = new DownCable(action, new NodeSet(doAllIndiv));
      DownCable objDC = new DownCable(obj, new NodeSet(hashedNodes));
      DownCableSet allCables = new DownCableSet(actionDC, objDC);
      Node shouldCreate = compareMolecularNode(allCables);
      if (shouldCreate == null)
        doAllActNode = (DoAllNode) network.createNode("doallnode", allCables);
      else
        doAllActNode = (DoAllNode) shouldCreate;
      CLI.print("Do All Act Node Created.");
      {
        if ("" != null)
          return doAllActNode;
      }
    } catch (NoSuchTypeException e) {
      // TODO Auto-generated catch block
      e.printStackTrace();
    }
    throw new Error("Missing return statement in function");
  }

  final public ActNode GuardedAct() throws ParseException, ParseException {
    Node actNode = null;
    Node prop = null;
    jj_consume_token(53);
    actNode = Act();
    jj_consume_token(27);
    prop = Expression();
    jj_consume_token(28);
    ResetGrading();
    // Relations
    Relation actRel = network.getRelations().get("act");
    Relation guardRel = network.getRelations().get("guard");

    // cables
    DownCable actDC = new DownCable(actRel, new NodeSet(actNode));
    DownCable guardDC = new DownCable(guardRel, new NodeSet(prop));

    DownCableSet allcables = new DownCableSet(actDC, guardDC);
    // creating guarded actnode
    ActNode guardedActNode = null;
    Node shouldCreate = compareMolecularNode(allcables);
    try {
      if (shouldCreate == null)
        guardedActNode = (ActNode) network.createNode("actnode", allcables);
      else
        guardedActNode = (ActNode) shouldCreate;
      CLI.print("Guarded Act Node Created.");
      {
        if ("" != null)
          return guardedActNode;
      }
    } catch (NoSuchTypeException e) {
      // TODO Auto-generated catch block
      e.printStackTrace();
    }
    throw new Error("Missing return statement in function");
  }

  final public MGIfNode MGIF() throws ParseException, ParseException {
    Node oneGuardAct = null;
    HashMap<String, Node> allGuardActs = new HashMap<String, Node>();
    jj_consume_token(54);
    oneGuardAct = GuardedAct();
    allGuardActs.put(oneGuardAct.getName(), oneGuardAct);
    label_8: while (true) {
      switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
        case 27: {
          ;
          break;
        }
        default:
          jj_la1[15] = jj_gen;
          break label_8;
      }
      jj_consume_token(27);
      oneGuardAct = GuardedAct();
      allGuardActs.put(oneGuardAct.getName(), oneGuardAct);
    }
    jj_consume_token(28);
    // relations
    Relation action = network.getRelations().get("action");
    Relation obj = network.getRelations().get("obj");

    // snif indiv node
    IndividualNode snifIndividual = null;
    MGIfNode snifActNode = null;
    try {
      if (network.getBaseNodes().containsKey("mgif"))
        snifIndividual = (IndividualNode) network.getBaseNodes().get("mgif");
      else
        snifIndividual = (IndividualNode) network.createNode("mgif", "individualnode"); // cables
      DownCable actionDC = new DownCable(action, new NodeSet(snifIndividual));
      DownCable objDC = new DownCable(obj, new NodeSet(allGuardActs));
      DownCableSet allCables = new DownCableSet(actionDC, objDC);

      // creating snif act node
      Node shouldCreate = compareMolecularNode(allCables);
      if (shouldCreate == null)
        snifActNode = (MGIfNode) network.createNode("mgifnode", allCables);
      else
        snifActNode = (MGIfNode) shouldCreate;
      CLI.print("MGIF Act Node Created.");
      {
        if ("" != null)
          return snifActNode;
      }
    } catch (NoSuchTypeException e) {
      // TODO Auto-generated catch block
      e.printStackTrace();
    }
    throw new Error("Missing return statement in function");
  }

  final public MGIterateNode SNIterate() throws ParseException, ParseException {
    Node oneGuardAct = null;
    HashMap<String, Node> allGuardActs = new HashMap<String, Node>();
    jj_consume_token(55);
    oneGuardAct = GuardedAct();
    allGuardActs.put(oneGuardAct.getName(), oneGuardAct);
    label_9: while (true) {
      switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
        case 27: {
          ;
          break;
        }
        default:
          jj_la1[16] = jj_gen;
          break label_9;
      }
      jj_consume_token(27);
      oneGuardAct = GuardedAct();
      allGuardActs.put(oneGuardAct.getName(), oneGuardAct);
    }
    jj_consume_token(28);
    // relations
    Relation action = network.getRelations().get("action");
    Relation obj = network.getRelations().get("obj");

    // sniterate indiv node
    IndividualNode sniterateIndividual = null;
    MGIterateNode sniterateActNode = null;
    try {
      if (network.getBaseNodes().containsKey("mgiterate"))
        sniterateIndividual = (IndividualNode) network.getBaseNodes().get("mgiterate");
      else
        sniterateIndividual = (IndividualNode) network.createNode("mgiterate", "individualnode");
      // cables
      DownCable actionDC = new DownCable(action, new NodeSet(sniterateIndividual));
      DownCable objDC = new DownCable(obj, new NodeSet(allGuardActs));
      DownCableSet allCables = new DownCableSet(actionDC, objDC);

      // creating sniterate act node
      Node shouldCreate = compareMolecularNode(allCables);
      if (shouldCreate == null)
        sniterateActNode = (MGIterateNode) network.createNode("mgiteratenode", allCables);
      else
        sniterateActNode = (MGIterateNode) shouldCreate;
      CLI.print("MGITERATE Act Node Created.");
      {
        if ("" != null)
          return sniterateActNode;
      }
    } catch (NoSuchTypeException e) {
      // TODO Auto-generated catch block
      e.printStackTrace();
    }
    throw new Error("Missing return statement in function");
  }

  final public Node AndOrThreshExpression(boolean quantifier) throws ParseException, ParseException {
    Token rule;
    Token i;
    Token j;
    Node node = null;
    ArrayList<Node> nodes = new ArrayList<Node>();
    firstExpression = false;
    isGrading = false;
    rule = jj_consume_token(ANDOR_THRESH);
    i = jj_consume_token(NUMBER);
    jj_consume_token(27);
    j = jj_consume_token(NUMBER);
    jj_consume_token(29);
    jj_consume_token(32);
    nodes = ExpressionList();
    jj_consume_token(28);
    String ruleType = rule.image.trim().toLowerCase();
    ruleType = ruleType.substring(0, ruleType.length() - 1);
    try {
      if (ruleType.equals("andor")) {
        Relation min = network.getRelations().get("min");
        Relation max = network.getRelations().get("max");
        Node minNode = network.createNode(i.image.trim(), "individualnode");
        Node maxNode = network.createNode(j.image.trim(), "individualnode");
        DownCable minCable = new DownCable(min, new NodeSet(minNode));
        DownCable maxCable = new DownCable(max, new NodeSet(maxNode));

        Relation arg = network.getRelations().get("arg");
        HashMap<String, Node> objs = new HashMap<String, Node>();
        for (Node n : nodes)
          objs.put(n.getName(), n);

        NodeSet set = new NodeSet(objs);
        DownCable andorDCB = new DownCable(arg, set);
        HashMap<String, DownCable> sett = new HashMap<String, DownCable>();
        if (quantifier) {
          DownCable quant = new DownCable(network.getRelations().get("forall"), new NodeSet(varNodesForall));
          sett.put(quant.getRelation().getName(), quant);
        }
        sett.put(minCable.getRelation().getName(), minCable);
        sett.put(maxCable.getRelation().getName(), maxCable);
        sett.put(andorDCB.getRelation().getName(), andorDCB);

        DownCableSet dcs = new DownCableSet(sett);
        Node shouldCreate = compareMolecularNode(dcs);
        if (shouldCreate == null)
          node = network.createNode("andor", new DownCableSet(sett));
        else
          node = shouldCreate;

      } else {
        Relation threshMax = network.getRelations().get("threshmax");
        Relation thresh = network.getRelations().get("thresh");
        Node threshMaxNode = network.createNode(i.image.trim(), "propositionnode");
        Node threshNode = network.createNode(j.image.trim(), "propositionnode");
        DownCable threshMaxCable = new DownCable(threshMax, new NodeSet(threshMaxNode));
        DownCable threshCable = new DownCable(thresh, new NodeSet(threshNode));

        Relation arg = network.getRelations().get("arg");
        HashMap<String, Node> objs = new HashMap<String, Node>();
        for (Node n : nodes)
          objs.put(n.getName(), n);
        NodeSet set = new NodeSet(objs);
        DownCable threshDCB = new DownCable(arg, set);
        HashMap<String, DownCable> sett = new HashMap<String, DownCable>();
        if (quantifier) {
          DownCable quant = new DownCable(network.getRelations().get("forall"), new NodeSet(varNodesForall));
          sett.put(quant.getRelation().getName(), quant);
        }
        sett.put(threshMaxCable.getRelation().getName(), threshMaxCable);
        sett.put(threshCable.getRelation().getName(), threshCable);
        sett.put(threshDCB.getRelation().getName(), threshDCB);
        DownCableSet dcs = new DownCableSet(sett);
        Node shouldCreate = compareMolecularNode(dcs);
        if (shouldCreate == null)
          node = network.createNode("thresh", new DownCableSet(sett));
        else
          node = shouldCreate;
      }

    } catch (NoSuchTypeException e) {
      // TODO Auto-generated catch block
      e.printStackTrace();
    }
    {
      if ("" != null)
        return node;
    }
    throw new Error("Missing return statement in function");
  }

  final public ArrayList<Node> ExpressionList() throws ParseException, ParseException {
    ArrayList<Node> nodes = new ArrayList<Node>();
    Node arg;
    arg = Expression();
    nodes.add(arg);
    label_10: while (true) {
      switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
        case 27: {
          ;
          break;
        }
        default:
          jj_la1[17] = jj_gen;
          break label_10;
      }
      jj_consume_token(27);
      arg = Expression();
      nodes.add(arg);
    }
    {
      if ("" != null)
        return nodes;
    }
    throw new Error("Missing return statement in function");
  }

  final public Node OrAndEntailment(boolean quantifier) throws ParseException, ParseException {
    firstExpression = false;
    ArrayList<Node> cq = new ArrayList<Node>();
    ArrayList<Node> ant = new ArrayList<Node>();
    isGrading = false;
    Token ent;
    jj_consume_token(32);
    ant = ExpressionList();
    jj_consume_token(28);
    ent = jj_consume_token(ENTAILMENT);
    jj_consume_token(32);
    cq = ExpressionList();
    jj_consume_token(28);
    HashMap<String, DownCable> sett = new HashMap<String, DownCable>();
    if (ent.image.trim().toLowerCase().equals("&=>")) {
      Relation antecedent = network.getRelations().get("&ant");
      Relation consequent = network.getRelations().get("cq");
      HashMap<String, Node> antHash = new HashMap<String, Node>();
      HashMap<String, Node> cqHash = new HashMap<String, Node>();
      Node andEntailmentNode = null;
      for (Node a : ant)
        antHash.put(a.getName(), a);
      DownCable antDC = new DownCable(antecedent, new NodeSet(antHash));
      for (Node a : cq)
        cqHash.put(a.getName(), a);
      DownCable cqDC = new DownCable(consequent, new NodeSet(cqHash));
      if (quantifier) {
        DownCable quant = new DownCable(network.getRelations().get("forall"), new NodeSet(varNodesForall));
        sett.put(quant.getRelation().getName(), quant);
      }
      sett.put(antDC.getRelation().getName(), antDC);
      sett.put(cqDC.getRelation().getName(), cqDC);
      DownCableSet dcs = new DownCableSet(sett);
      Node shouldCreate = compareMolecularNode(dcs);
      try {
        if (shouldCreate == null)
          andEntailmentNode = network.createNode("andentailment", new DownCableSet(sett));
        else
          andEntailmentNode = shouldCreate;
      } catch (NoSuchTypeException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
      }

      {
        if ("" != null)
          return andEntailmentNode;
      }
    } else {
      if (ent.image.trim().toLowerCase().equals("&=>")) {
        Relation antecedent = network.getRelations().get("ant");
        Relation consequent = network.getRelations().get("cq");
        HashMap<String, Node> antHash = new HashMap<String, Node>();
        HashMap<String, Node> cqHash = new HashMap<String, Node>();
        Node orEntailmentNode = null;
        for (Node a : ant)
          antHash.put(a.getName(), a);
        DownCable antDC = new DownCable(antecedent, new NodeSet(antHash));
        for (Node a : cq)
          cqHash.put(a.getName(), a);
        DownCable cqDC = new DownCable(consequent, new NodeSet(cqHash));
        if (quantifier) {
          DownCable quant = new DownCable(network.getRelations().get("forall"), new NodeSet(varNodesForall));
          sett.put(quant.getRelation().getName(), quant);
        }
        sett.put(antDC.getRelation().getName(), antDC);
        sett.put(cqDC.getRelation().getName(), cqDC);
        DownCableSet dcs = new DownCableSet(sett);
        Node shouldCreate = compareMolecularNode(dcs);
        try {
          if (shouldCreate == null)
            orEntailmentNode = network.createNode("orentailment", new DownCableSet(sett));
          else
            orEntailmentNode = shouldCreate;
        } catch (NoSuchTypeException e) {
          // TODO Auto-generated catch block
          e.printStackTrace();
        }

        {
          if ("" != null)
            return orEntailmentNode;
        }
      } else {
        String i = ent.image.trim().toLowerCase().charAt(0) + "";
        Relation antecedent = network.getRelations().get("&ant");
        Relation consequent = network.getRelations().get("cq");
        HashMap<String, Node> antHash = new HashMap<String, Node>();
        HashMap<String, Node> cqHash = new HashMap<String, Node>();
        Node iEntailmentNode = null;
        Node iNode = null;
        try {
          iNode = network.createNode(i, "individualNode");
          DownCable iDC = new DownCable(network.getRelations().get("i"), new NodeSet(iNode));
          for (Node a : ant)
            antHash.put(a.getName(), a);
          DownCable antDC = new DownCable(antecedent, new NodeSet(antHash));
          for (Node a : cq)
            cqHash.put(a.getName(), a);
          DownCable cqDC = new DownCable(consequent, new NodeSet(cqHash));

          if (quantifier) {
            DownCable quant = new DownCable(network.getRelations().get("forall"), new NodeSet(varNodesForall));
            sett.put(quant.getRelation().getName(), quant);
          }
          sett.put(antDC.getRelation().getName(), antDC);
          sett.put(cqDC.getRelation().getName(), cqDC);
          sett.put(iDC.getRelation().getName(), iDC);
          DownCableSet dcs = new DownCableSet(sett);
          Node shouldCreate = compareMolecularNode(dcs);
          if (shouldCreate == null)
            iEntailmentNode = network.createNode("numentailment", new DownCableSet(sett));
          else
            iEntailmentNode = shouldCreate;
        } catch (NoSuchTypeException e) {
          // TODO Auto-generated catch block
          e.printStackTrace();
        }
        {
          if ("" != null) {
            if ("" != null)
              return iEntailmentNode;
          }
        }

      }
    }
    throw new Error("Missing return statement in function");
  }

  final public Node negatedProp() throws ParseException {
    firstExpression = false;
    Node node = null;
    isGrading = false;
    jj_consume_token(25);
    node = Expression();
    Node negatedNode = null;
    try {
      negatedNode = node.createNegation(node);
    } catch (NoSuchTypeException e) {
      // TODO Auto-generated catch block
      e.printStackTrace();
    }
    {
      if ("" != null)
        return negatedNode;
    }
    throw new Error("Missing return statement in function");
  }

  final public Node gradedProp() throws ParseException {
    Node node = null;
    String gradeValue;
    if (firstExpression || isGrading) {
      levelsCount++;
      firstExpression = false;
    }
    jj_consume_token(26);
    node = Expression();
    jj_consume_token(27);
    gradeValue = jj_consume_token(NUMBER).image;
    jj_consume_token(28);
    gradeValue = gradeValue.trim();
    // Relations
    Relation grade = network.getRelations().get("grade");
    Relation prop = network.getRelations().get("prop");

    // nodes
    Node gradeNode = null;
    Node molecNode = null;
    try {
      gradeNode = network.createNode(gradeValue, "individualnode");
      // cables
      DownCable gradeDC = new DownCable(grade, new NodeSet(gradeNode));
      DownCable propDC = new DownCable(prop, new NodeSet(node));
      DownCableSet alldcs = new DownCableSet(gradeDC, propDC);
      Node shouldCreate = compareMolecularNode(alldcs);
      if (shouldCreate == null)
        molecNode = network.createNode("propositionnode", alldcs);
      else
        molecNode = shouldCreate;
    } catch (NoSuchTypeException e) {
      // TODO Auto-generated catch block
      e.printStackTrace();
    }

    {
      if ("" != null)
        return molecNode;
    }
    throw new Error("Missing return statement in function");
  }

  final public Node Predicate() throws ParseException {
    Token num;
    Token predicateName;
    firstExpression = false;
    isGrading = false;
    predicateName = jj_consume_token(PREDICATE_NAME_BRACKET);
    Arguments(predicateName.image.toLowerCase());
    jj_consume_token(29);
    String pNodeName = predicateName.image.trim().toLowerCase();
    pNodeName = pNodeName.substring(0, pNodeName.length() - 1);
    Node pNode = null;
    Node molec = null;
    Relation rel = null;
    try {
      pNode = network.createNode(pNodeName, "propositionnode");
      if (mode == 1)
        rel = network.createRelation("r", "propositionnode", Adjustability.EXPAND, 2);
      if (mode == 2)
        rel = network.createRelation("rel" + pNodeName, "propositionnode", Adjustability.EXPAND, 2);
      if (rel == null && mode != 3) {
        {
          if (true)
            throw new ParseException("rel is null");
        }
      }
      if (mode != 3) {
        DownCable lastCable = new DownCable(rel, new NodeSet(pNode));
        allDCB.put(lastCable.getRelation().getName(), lastCable);
      }
      HashMap<String, DownCable> cloneAllDCB = new HashMap<String, DownCable>();
      for (DownCable x : allDCB.values())
        cloneAllDCB.put(x.getRelation().getName(), x);
      DownCableSet dcs = new DownCableSet(cloneAllDCB);
      Node shouldCreate = compareMolecularNode(dcs);
      if (shouldCreate == null)
        molec = network.createNode("propositionnode", dcs);
      else
        molec = shouldCreate;
      allDCB.clear();

    } catch (NoSuchTypeException e) {
      // TODO Auto-generated catch block
      e.printStackTrace();
    }
    {
      if ("" != null)
        return molec;
    }
    throw new Error("Missing return statement in function");
  }

  final public void Arguments(String pName) throws ParseException {
    ArrayList<Node> leafNodes = new ArrayList<Node>();
    Node arg;
    pName = pName.substring(0, pName.length() - 1);
    arg = Argument();
    leafNodes.add(arg);
    label_11: while (true) {
      switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
        case 27: {
          ;
          break;
        }
        default:
          jj_la1[18] = jj_gen;
          break label_11;
      }
      jj_consume_token(27);
      arg = Argument();
      leafNodes.add(arg);
    }
    if (mode == 3) {
      if (!caseFrames.containsKey(pName)) {
        if (true)
          throw new ParseException("No Such Case Frame.");
      }
      ArrayList<String> frame = caseFrames.get(pName);
      Relation firstRel = null;
      if (frame.get(0) != "null") {
        firstRel = network.createRelation(frame.get(1), "propositionnode", Adjustability.EXPAND, 2);
        DownCable dcb = null;
        try {
          dcb = new DownCable(firstRel, new NodeSet(network.createNode(pName, "propositionnode")));
          allDCB.put(dcb.getRelation().getName(), dcb);

        } catch (NoSuchTypeException e) {
          // TODO Auto-generated catch block
          e.printStackTrace();
        }
      }
      for (int i = 0; i < leafNodes.size(); i++) {
        Relation r = network.createRelation(frame.get(i + 1), "propositionnode", Adjustability.EXPAND, 2);
        DownCable dcb = new DownCable(r, new NodeSet(leafNodes.get(i)));
        allDCB.put(dcb.getRelation().getName(), dcb);
      }

    } else {
      for (int i = 0; i < leafNodes.size(); i++) {
        Node variableN = leafNodes.get(i);
        Relation rel = null;
        if (mode == 1)
          rel = network.createRelation("a" + (i + 1), "propositionnode", Adjustability.EXPAND, 2);
        if (mode == 2)
          rel = network.createRelation("rel - arg#" + pName + (i + 1), "propositionnode", Adjustability.EXPAND, 2);
        if (rel == null) {
          if (true)
            throw new ParseException("rel is null");
        }
        DownCable dcb = new DownCable(rel, new NodeSet(variableN));
        allDCB.put(dcb.getRelation().getName(), dcb);
      }
    }
  }

  final public Node Argument() throws ParseException {
    Token Argument;
    Token var = null;
    Node leafNode = null;
    switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
      case STRING: {
        Argument = jj_consume_token(STRING);
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
          case VARIABLE: {
            var = jj_consume_token(VARIABLE);
            break;
          }
          default:
            jj_la1[19] = jj_gen;
            ;
        }
        String argString = Argument.image.trim().toLowerCase();
        System.out.println(argString);
        try {
          if (var != null)
            leafNode = network.createVariableNode(argString, "propositionnode");
          else
            leafNode = network.createNode(argString, "propositionnode");
        } catch (NoSuchTypeException e) {
          // TODO Auto-generated catch block
          e.printStackTrace();
        }
        {
          if ("" != null)
            return leafNode;
        }
        break;
      }
      case ANDOR_THRESH:
      case WHENDO_DOIF:
      case QUANTIFIER:
      case PREDICATE_NAME_BRACKET:
      case 25:
      case 26:
      case 32: {
        leafNode = Expression();
        {
          if ("" != null)
            return leafNode;
        }
        break;
      }
      default:
        jj_la1[20] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public void defineFrame() throws ParseException, ParseException {
    ArrayList<String> allRelationNames = new ArrayList<String>();
    String relName;
    Token predicateName;
    predicateName = jj_consume_token(PREDICATE_NAME_BRACKET);
    relName = relationName();
    if (!allRelationNames.contains(relName))
      allRelationNames.add(relName);
    label_12: while (true) {
      switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
        case 27: {
          ;
          break;
        }
        default:
          jj_la1[21] = jj_gen;
          break label_12;
      }
      jj_consume_token(27);
      relName = relationName();
      if (!allRelationNames.contains(relName))
        allRelationNames.add(relName);
    }
    jj_consume_token(29);
    jj_consume_token(0);
    String predName = predicateName.image.trim().toLowerCase();
    predName = predName.substring(0, predName.length() - 1);

    // Add listToAdd to listOfLists
    boolean isFirst = true;
    caseFrames.put(predName, allRelationNames);
    String output = "Case Frame " + predName + "(";
    for (String s : allRelationNames) {
      if (!isFirst)
        output += ", " + s;
      else
        output += s;
    }
    output += ") is Defined.";
    CLI.print(output);
  }

  final public String relationName() throws ParseException, ParseException {
    Token s;
    s = jj_consume_token(STRING);
    String relationName = s.image.trim().toLowerCase();
    {
      if ("" != null)
        return relationName;
    }
    throw new Error("Missing return statement in function");
  }

  final public void Command() throws ParseException, ParseException {
    Token stringToken;
    Token t = null;
    Token wffNameList = null;
    Token attitudeSet = null;
    switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
      case currContext:
      case GetAttitudeNames:
      case MODE1:
      case MODE2:
      case MODE3:
      case 115: {
        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
          case currContext: {
            jj_consume_token(currContext);
            try {
              String s = ContextController.getCurrContextName();
              System.out.println(s);
            } catch (Exception e) {
              System.out.println("No Current Context");
            }
            break;
          }
          case GetAttitudeNames: {
            jj_consume_token(GetAttitudeNames);
            HashMap<String, Integer> attitudeNames = ContextController.getAttitudes().getSet();
            System.out.println("List of attitude names:");

            // Iterate over the attitude names and print them
            for (String key : attitudeNames.keySet()) {
              System.out.println(key);
            }
            break;
          }
          case MODE1: {
            jj_consume_token(MODE1);
            mode = 1;
            System.out.println("Operating in mode 1 (Default)");
            System.out.println(mode);
            break;
          }
          case MODE2: {
            jj_consume_token(MODE2);
            mode = 2;
            System.out.println("Operating in mode 2");
            System.out.println(mode);
            break;
          }
          case MODE3: {
            jj_consume_token(MODE3);
            mode = 3;
            System.out.println("Operating in mode 3");
            System.out.println(mode);
            break;
          }
          case 115: {
            defineContext();
            break;
          }
          default:
            jj_la1[22] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
        }
        break;
      }
      case 56: {
        jj_consume_token(56);
        defineFrame();
        break;
      }
      case 57: {
        jj_consume_token(57);
        defineSemantic();
        break;
      }
      case 58: {
        Token CName;
        jj_consume_token(58);
        Bridge();
        HashMap<String, HashMap<String, Node>> molecN = network.getMolecularNodes();
        for (HashMap<String, Node> x : molecN.values()) {
          for (Node n : x.values()) {
            System.out.println(n.toString());
          }

        }
        break;
      }
      case 81: {
        setCurrentContext();
        break;
      }
      case 80: {
        getAllContexts();
        break;
      }
      case 77: {
        forwardInference();
        break;
      }
      case 78: {
        activate();
        break;
      }
      case 79: {
        AssertActivate();
        break;
      }
      case 82: {
        setCurrentAttitude();
        break;
      }
      case 76: {
        AddToContext();
        break;
      }
      case 75: {
        RemoveFromContext();
        break;
      }
      case 48: {
        definePath();
        break;
      }
      case 59: {
        jj_consume_token(59);
        Relation();
        break;
      }
      case 74: {
        DescribeContext();
        break;
      }
      case 73: {
        getAllSupported();
        break;
      }
      case 67: {
        performAct();
        break;
      }
      case 65: {
        clearNetwork();
        break;
      }
      case 66: {
        clearInfer();
        break;
      }
      case 60: {
        jj_consume_token(60);
        backwardInference();
        break;
      }
      case 61: {
        jj_consume_token(61);
        Ask();
        break;
      }
      case 62: {
        jj_consume_token(62);
        AskifNot();
        break;
      }
      case 63: {
        jj_consume_token(63);
        AskWh();
        break;
      }
      case 64: {
        jj_consume_token(64);
        AskWhNot();
        break;
      }
      default:
        jj_la1[23] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
    }
  }

  final public void clearNetwork() throws ParseException, ParseException {
    jj_consume_token(65);
    network.setBaseNodes(new HashMap<String, Node>());
    network.setNodes(new HashMap<Integer, Node>());
    network.setMolecularNodes(new HashMap<String, HashMap<String, Node>>());
    network.setRelations(new HashMap<String, Relation>());
    network.getPropositionNodes().clear();

    CLI.print("Network is Cleared.");
  }

  final public void clearInfer() throws ParseException, ParseException {
    jj_consume_token(66);
    String x;
  }

  final public void performAct() throws ParseException, ParseException {
    Node node = null;
    ActNode actNode = null;
    jj_consume_token(67);
    node = Act();
    actNode = (ActNode) node;

    try {
      actNode.perform();
    } catch (NoSuchTypeException e) {
      // TODO Auto-generated catch block
      CLI.print(e.getMessage());
    } catch (NoPlansExistForTheActException e) {
      // TODO Auto-generated catch block
      CLI.print(e.getMessage());
    } catch (DirectCycleException e) {
      // TODO Auto-generated catch block
      CLI.print(e.getMessage());
    }
  }

  final public ActNode defineNonPrimitive() throws ParseException, ParseException {
    ActNode plan = null;
    String actName = null;
    boolean p = false;
    String obj = null;
    jj_consume_token(68);
    actName = jj_consume_token(STRING).image;
    obj = jj_consume_token(STRING).image;
    switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
      case 33:
      case 49:
      case 50:
      case 51:
      case 52:
      case 53:
      case 54:
      case 55: {
        plan = Act();
        p = true;
        break;
      }
      default:
        jj_la1[24] = jj_gen;
        ;
    }
    try {

      actName = actName.trim().toLowerCase();
      obj = obj.trim().toLowerCase();
      IndividualNode actionNode = null;
      IndividualNode objNode = null;
      // relations
      Relation action = network.getRelations().get("action");
      Relation object = network.getRelations().get("object");
      Relation act = network.getRelations().get("act");
      Relation planRel = network.getRelations().get("plan");
      // nodes
      if (network.getBaseNodes().containsKey(actName))
        actionNode = (IndividualNode) network.getBaseNodes().get(actName);
      else
        actionNode = (IndividualNode) network.createNode(actName, "individualnode");
      if (network.getBaseNodes().containsKey(obj))
        actionNode = (IndividualNode) network.getBaseNodes().get(obj);
      else
        actionNode = (IndividualNode) network.createNode(obj, "individualnode");

      // downcables
      DownCable actionDC = new DownCable(action, new NodeSet(actionNode));
      DownCable objDC = new DownCable(object, new NodeSet(objNode));

      DownCableSet actNodeset = new DownCableSet(actionDC, objDC);

      Node shouldCreate = compareMolecularNode(actNodeset);
      ActNode actNode = null;
      if (shouldCreate == null)
        actNode = (ActNode) network.createNode("actnode", actNodeset);
      else
        actNode = (ActNode) shouldCreate;
      DownCable actDC = new DownCable(act, new NodeSet(actNode));
      if (p) {
        DownCable planDC = new DownCable(planRel, new NodeSet(plan)); // p
        DownCableSet planACtDC = new DownCableSet(planDC, actDC);// p

        ActNode planActNode = null; // p
        Node shouldCreate2 = compareMolecularNode(planACtDC); // p
        if (shouldCreate2 == null) // p
          planActNode = (ActNode) network.createNode("actnode", planACtDC);
        else
          planActNode = (ActNode) shouldCreate2;
        CLI.print("Non-Primitive Act '" + actName + "' with Plan is Defined.");
        {
          if ("" != null)
            return planActNode;
        } // p
      }
      CLI.print("Non-Primitive Act '" + actName + "' is Defined.");

      {
        if ("" != null)
          return actNode;
      }
    } catch (NoSuchTypeException e) {
      // TODO Auto-generated catch block
      e.printStackTrace();
      {
        if ("" != null)
          return null;
      }
    }
    throw new Error("Missing return statement in function");
  }

  final public void definePrimitive() throws ParseException, ParseException {
    String fileName = null;
    String actName = null;
    boolean p = false;
    jj_consume_token(69);
    actName = jj_consume_token(STRING).image;
    fileName = jj_consume_token(STRING).image;
    String xxxxxxxxxxxxxxxxxx;
  }

  final public void getAllSupportedInContext() throws ParseException, ParseException {
    String CName = null;
    boolean c = false;
    boolean a = false;
    String attitude = null;
    jj_consume_token(70);
    switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
      case 71: {
        jj_consume_token(71);
        CName = jj_consume_token(STRING).image;
        jj_consume_token(28);
        c = true;
        break;
      }
      default:
        jj_la1[25] = jj_gen;
        ;
    }
    switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
      case 72: {
        jj_consume_token(72);
        attitude = jj_consume_token(STRING).image;
        jj_consume_token(28);
        a = true;
        break;
      }
      default:
        jj_la1[26] = jj_gen;
        ;
    }

  }

  final public void getAllSupported() throws ParseException, ParseException {
    jj_consume_token(73);
    CLI.print("Printing All Hypotheses Supported in All Contexts...");
    HashMap<String, Context> contextSet = controller.getContextSet().getSet();
    for (Context c : contextSet.values()) {
      CLI.print("Context " + c + ":");
      Collection<Pair<PropositionNodeSet, PropositionNodeSet>[]> hyps = c.getHypotheses().values();
      for (Pair<PropositionNodeSet, PropositionNodeSet>[] pairArray : hyps) {
        for (Pair<PropositionNodeSet, PropositionNodeSet> pair : pairArray) {
          Collection<Node> firstSet = pair.getFirst().getNodes();
          Collection<Node> secondSet = pair.getSecond().getNodes();
          CLI.print("Ungraded Nodes:");
          for (Node n : firstSet)
            CLI.print(n.toString());

          CLI.print("Graded Nodes:");
          for (Node n : secondSet)
            CLI.print(n.toString());

        }
      }
      CLI.print("");

    }
  }

  final public void DescribeContext() throws ParseException, ParseException {
    String CName = null;
    jj_consume_token(74);
    switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
      case STRING: {
        CName = jj_consume_token(STRING).image;
        break;
      }
      default:
        jj_la1[27] = jj_gen;
        ;
    }
    if (CName == null) {
      try {
        CName = controller.getCurrContextName();
        CName = CName.trim();
      } catch (Exception e) {
        CLI.print("Set Default Context First.");
      }

    } else {
      CName = CName.trim();
      if (!controller.getContextSet().getSet().containsKey(CName.trim())) {
        if (true)
          throw new ParseException("Context Does Not Exist.");
      }
      CLI.print("Hypothesis in Context " + CName + ":");
      for (ArrayList<String> contexts : wffs.values()) {
        String wffName = contexts.get(0);
        for (int i = 1; i < contexts.size(); i++) {
          String cxt = contexts.get(i);
          String[] name_attitude = cxt.split("_");
          CLI.print(wffName + " supported in attitude " + name_attitude[1]);
        }

      }
    }
  }

  final public void RemoveFromContext() throws ParseException, ParseException {
    String CName = null;
    boolean c = false;
    boolean a = false;
    Node node = null;
    String attitude = null;
    jj_consume_token(75);
    switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
      case 71: {
        jj_consume_token(71);
        CName = jj_consume_token(STRING).image;
        jj_consume_token(28);
        c = true;
        break;
      }
      default:
        jj_la1[28] = jj_gen;
        ;
    }
    switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
      case 72: {
        jj_consume_token(72);
        attitude = jj_consume_token(STRING).image;
        jj_consume_token(28);
        a = true;
        break;
      }
      default:
        jj_la1[29] = jj_gen;
        ;
    }
    node = Expression();
    PropositionNode propNode = (PropositionNode) node;
    removeFromContext(CName, attitude, a, c, propNode);
    firstExpression = true;
    isGrading = true;
    levelsCount = 0;
  }

  final public void AddToContext() throws ParseException, ParseException {
    String attitude = null;
    String CName = null;
    Node nn;
    boolean c = false;
    boolean a = false;
    jj_consume_token(76);
    switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
      case 71: {
        jj_consume_token(71);
        CName = jj_consume_token(STRING).image;
        jj_consume_token(28);
        c = true;
        break;
      }
      default:
        jj_la1[30] = jj_gen;
        ;
    }
    switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
      case 72: {
        jj_consume_token(72);
        attitude = jj_consume_token(STRING).image;
        jj_consume_token(28);
        a = true;
        break;
      }
      default:
        jj_la1[31] = jj_gen;
        ;
    }
    nn = Expression();
    PropositionNode propNode = (PropositionNode) nn;
    addToContext(CName, attitude, a, c, propNode);
    firstExpression = true;
    isGrading = true;
    levelsCount = 0;
    // printing
    HashMap<String, HashMap<String, Node>> molecN = network.getMolecularNodes();
    for (HashMap<String, Node> x : molecN.values()) {
      for (Node n : x.values()) {
        System.out.println(n.toString());
      }
    }
  }

  final public void backwardInference() throws ParseException, ParseException {
    String attitude = null;
    String CName = null;
    Node node;
    boolean c = false;
    boolean a = false;
    switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
      case 71: {
        jj_consume_token(71);
        CName = jj_consume_token(STRING).image;
        jj_consume_token(28);
        c = true;
        break;
      }
      default:
        jj_la1[32] = jj_gen;
        ;
    }
    switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
      case 72: {
        jj_consume_token(72);
        attitude = jj_consume_token(STRING).image;
        jj_consume_token(28);
        a = true;
        break;
      }
      default:
        jj_la1[33] = jj_gen;
        ;
    }
    node = Expression();
    PropositionNode propNode = (PropositionNode) node;
    bInference(propNode, c, a, CName, attitude);
    firstExpression = true;
    isGrading = true;
    levelsCount = 0;
  }

  final public void AskWh() throws ParseException, ParseException {
    String attitude = null;
    String CName = null;
    Node node;
    boolean c = false;
    boolean a = false;
    switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
      case 71: {
        jj_consume_token(71);
        CName = jj_consume_token(STRING).image;
        jj_consume_token(28);
        c = true;
        break;
      }
      default:
        jj_la1[34] = jj_gen;
        ;
    }
    switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
      case 72: {
        jj_consume_token(72);
        attitude = jj_consume_token(STRING).image;
        jj_consume_token(28);
        a = true;
        break;
      }
      default:
        jj_la1[35] = jj_gen;
        ;
    }
    node = Expression();
    PropositionNode propNode = (PropositionNode) node;
    bInference(propNode, c, a, CName, attitude);
    Hashtable<Integer, Hashtable<Substitutions, KnownInstance>> positiveInstances = propNode
        .getKnownInstances().positiveKInstances;

    Hashtable<Integer, Hashtable<Substitutions, KnownInstance>> negativeInstances = propNode
        .getKnownInstances().negativeKInstances;
    for (Hashtable<Substitutions, KnownInstance> value : positiveInstances.values()) {
      for (Substitutions sub : value.keySet()) {
        for (HashMap.Entry<Node, Node> entry : sub.getMap().entrySet()) {
          CLI.print("Variable: " + entry.getKey().toString() + ", Value: " + entry.getValue().toString());
        }
      }
    }
    for (Hashtable<Substitutions, KnownInstance> value : negativeInstances.values()) {
      for (Substitutions sub : value.keySet()) {
        for (HashMap.Entry<Node, Node> entry : sub.getMap().entrySet()) {
          CLI.print("Variable: " + entry.getKey().toString() + ", Value: " + entry.getValue().toString());
        }
      }
    }
    firstExpression = true;
    isGrading = true;
    levelsCount = 0;
  }

  final public void AskWhNot() throws ParseException, ParseException {
    String attitude = null;
    String CName = null;
    Node node;
    boolean c = false;
    boolean a = false;
    switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
      case 71: {
        jj_consume_token(71);
        CName = jj_consume_token(STRING).image;
        jj_consume_token(28);
        c = true;
        break;
      }
      default:
        jj_la1[36] = jj_gen;
        ;
    }
    switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
      case 72: {
        jj_consume_token(72);
        attitude = jj_consume_token(STRING).image;
        jj_consume_token(28);
        a = true;
        break;
      }
      default:
        jj_la1[37] = jj_gen;
        ;
    }
    node = Expression();
    PropositionNode propNode = (PropositionNode) node;
    bInference(propNode, c, a, CName, attitude);
    PropositionNode negatedProp = null;
    try {
      negatedProp = (PropositionNode) propNode.createNegation(propNode);
    } catch (NoSuchTypeException e) {
      // TODO Auto-generated catch block
      CLI.print(e.getMessage());
    }
    Hashtable<Integer, Hashtable<Substitutions, KnownInstance>> positiveInstances = negatedProp
        .getKnownInstances().positiveKInstances;

    Hashtable<Integer, Hashtable<Substitutions, KnownInstance>> negativeInstances = negatedProp
        .getKnownInstances().negativeKInstances;
    for (Hashtable<Substitutions, KnownInstance> value : positiveInstances.values()) {
      for (Substitutions sub : value.keySet()) {
        for (HashMap.Entry<Node, Node> entry : sub.getMap().entrySet()) {
          CLI.print("Variable: " + entry.getKey().toString() + ", Value: " + entry.getValue().toString());
        }
      }
    }
    for (Hashtable<Substitutions, KnownInstance> value : negativeInstances.values()) {
      for (Substitutions sub : value.keySet()) {
        for (HashMap.Entry<Node, Node> entry : sub.getMap().entrySet()) {
          CLI.print("Variable: " + entry.getKey().toString() + ", Value: " + entry.getValue().toString());
        }
      }
    }
    firstExpression = true;
    isGrading = true;
    levelsCount = 0;
  }

  final public void AskifNot() throws ParseException, ParseException {
    String attitude = null;
    String CName = null;
    Node node;
    boolean c = false;
    boolean a = false;
    switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
      case 71: {
        jj_consume_token(71);
        CName = jj_consume_token(STRING).image;
        jj_consume_token(28);
        c = true;
        break;
      }
      default:
        jj_la1[38] = jj_gen;
        ;
    }
    switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
      case 72: {
        jj_consume_token(72);
        attitude = jj_consume_token(STRING).image;
        jj_consume_token(28);
        a = true;
        break;
      }
      default:
        jj_la1[39] = jj_gen;
        ;
    }
    node = Expression();
    PropositionNode propNode = (PropositionNode) node;
    bInference(propNode, c, a, CName, attitude);
    Hashtable<Integer, Hashtable<Substitutions, KnownInstance>> negativeInstances = propNode
        .getKnownInstances().negativeKInstances;
    for (Hashtable<Substitutions, KnownInstance> value : negativeInstances.values()) {
      for (KnownInstance KI : value.values()) {
        CLI.print(KI.toString());
      }
    }
    firstExpression = true;
    isGrading = true;
    levelsCount = 0;
  }

  final public void Ask() throws ParseException, ParseException {
    String attitude = null;
    String CName = null;
    Node node;
    boolean c = false;
    boolean a = false;
    switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
      case 71: {
        jj_consume_token(71);
        CName = jj_consume_token(STRING).image;
        jj_consume_token(28);
        c = true;
        break;
      }
      default:
        jj_la1[40] = jj_gen;
        ;
    }
    switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
      case 72: {
        jj_consume_token(72);
        attitude = jj_consume_token(STRING).image;
        jj_consume_token(28);
        a = true;
        break;
      }
      default:
        jj_la1[41] = jj_gen;
        ;
    }
    node = Expression();
    PropositionNode propNode = (PropositionNode) node;
    bInference(propNode, c, a, CName, attitude);
    Hashtable<Integer, Hashtable<Substitutions, KnownInstance>> positiveInstances = propNode
        .getKnownInstances().positiveKInstances;
    for (Hashtable<Substitutions, KnownInstance> value : positiveInstances.values()) {
      for (KnownInstance KI : value.values()) {
        CLI.print(KI.toString());
      }
    }
    firstExpression = true;
    isGrading = true;
    levelsCount = 0;
  }

  final public void forwardInference() throws ParseException, ParseException {
    Node node = null;
    String CName = null;
    String attitude = null;
    boolean c = false;
    boolean a = false;
    jj_consume_token(77);
    switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
      case 71: {
        jj_consume_token(71);
        CName = jj_consume_token(STRING).image;
        jj_consume_token(28);
        c = true;
        break;
      }
      default:
        jj_la1[42] = jj_gen;
        ;
    }
    switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
      case 72: {
        jj_consume_token(72);
        attitude = jj_consume_token(STRING).image;
        jj_consume_token(28);
        a = true;
        break;
      }
      default:
        jj_la1[43] = jj_gen;
        ;
    }
    node = Expression();
    PropositionNode propNode = (PropositionNode) node;
    fInference(propNode, c, a, CName, attitude);
    firstExpression = true;
    isGrading = true;
    levelsCount = 0;
  }

  final public void activate() throws ParseException, ParseException {
    String CName = null;
    boolean c = false;
    boolean a = false;
    Node node = null;
    String attitude = null;
    jj_consume_token(78);
    switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
      case 71: {
        jj_consume_token(71);
        CName = jj_consume_token(STRING).image;
        jj_consume_token(28);
        c = true;
        break;
      }
      default:
        jj_la1[44] = jj_gen;
        ;
    }
    switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
      case 72: {
        jj_consume_token(72);
        attitude = jj_consume_token(STRING).image;
        jj_consume_token(28);
        a = true;
        break;
      }
      default:
        jj_la1[45] = jj_gen;
        ;
    }
    node = Expression();
    PropositionNode propNode = (PropositionNode) node;

    Collection<Node> set = propNode.getDirectParents().getValues();
    for (Node n : set) {
      if (isSupported(propNode, c, a, CName, attitude) == 1)
        fInference(propNode, c, a, CName, attitude);
    }
    firstExpression = true;
    isGrading = true;
    levelsCount = 0;
  }

  final public void AssertActivate() throws ParseException, ParseException {
    String CName = null;
    boolean c = false;
    boolean a = false;
    Node node = null;
    String attitude = null;
    jj_consume_token(79);
    switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
      case 71: {
        jj_consume_token(71);
        CName = jj_consume_token(STRING).image;
        jj_consume_token(28);
        c = true;
        break;
      }
      default:
        jj_la1[46] = jj_gen;
        ;
    }
    switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
      case 72: {
        jj_consume_token(72);
        attitude = jj_consume_token(STRING).image;
        jj_consume_token(28);
        a = true;
        break;
      }
      default:
        jj_la1[47] = jj_gen;
        ;
    }
    node = Expression();
    PropositionNode propNode = (PropositionNode) node;
    addToContext(CName, attitude, a, c, propNode);
    Collection<Node> set = propNode.getDirectParents().getValues();
    for (Node n : set) {
      if (isSupported(propNode, c, a, CName, attitude) == 1)
        fInference(propNode, c, a, CName, attitude);
    }
    firstExpression = true;
    isGrading = true;
    levelsCount = 0;
  }

  final public void getAllContexts() throws ParseException, ParseException {
    jj_consume_token(80);
    HashMap<String, Context> set = controller.getContextSet().getSet();
    System.out.println("All Contexts Defined:");
    for (String cName : set.keySet()) {
      System.out.println(cName);
    }
  }

  final public void setCurrentContext() throws ParseException, ParseException {
    String cName;
    jj_consume_token(81);
    cName = jj_consume_token(STRING).image;
    cName = cName.trim().toLowerCase();
    try {
      controller.setCurrContext(cName);
      CLI.print("Current Context is Set to " + cName);
    } catch (Exception e) {
      System.out.println(e.getMessage());
      // TODO: handle exception
    }
  }

  final public void setCurrentAttitude() throws ParseException, ParseException {
    String attitude;
    jj_consume_token(82);
    attitude = jj_consume_token(STRING).image;
    attitude = attitude.trim().toLowerCase();

    Integer num = controller.getAttitudeNumber(attitude);
    if (num == null) {
      CLI.print(
          "no such attitude. The current default attitude is " + controller.getAttitudeName(defaultAttitude) + ".");

    } else {
      defaultAttitude = num;
      CLI.print("The default attitude has been set to " + attitude + ".");
    }
  }

  final public Node Bridge() throws ParseException, ParseException {
    HashMap<Node, Integer> antec = new HashMap<Node, Integer>();
    HashMap<Node, Integer> conseq = new HashMap<Node, Integer>();
    jj_consume_token(32);
    antec = bridgeExpressionList();
    jj_consume_token(28);
    jj_consume_token(32);
    conseq = bridgeExpressionList();
    jj_consume_token(28);
    HashMap<Integer, ArrayList<Node>> antecGroupedByAttitude = groupByValue(antec);
    HashMap<Integer, ArrayList<Node>> conseqGroupedByAttitude = groupByValue(conseq);
    HashMap<String, DownCable> allDCs = new HashMap<String, DownCable>();
    for (Integer n : antecGroupedByAttitude.keySet())
      System.out.println(n + " lol");
    for (Integer n : antecGroupedByAttitude.keySet()) {
      ArrayList<Node> nodes = antecGroupedByAttitude.get(n);
      Relation antRel = network.createRelation(n + "-ant", "propositionnode", Adjustability.EXPAND, 2);
      NodeSet set = new NodeSet();
      for (Node node : nodes)
        set.add(node);
      DownCable dc = new DownCable(antRel, set);
      allDCs.put(antRel.getName(), dc);
    }

    for (Integer n : conseqGroupedByAttitude.keySet()) {
      ArrayList<Node> nodes = conseqGroupedByAttitude.get(n);
      Relation conseqRel = network.createRelation(n + "-cq", "propositionnode", Adjustability.EXPAND, 2);
      NodeSet set = new NodeSet();
      for (Node node : nodes)
        set.add(node);
      DownCable dc = new DownCable(conseqRel, set);
      allDCs.put(conseqRel.getName(), dc);
    }
    Node bridgeNode = null;
    DownCableSet allDBs = new DownCableSet(allDCs);
    try {
      Node shouldCreate = compareMolecularNode(allDBs);
      if (shouldCreate == null)
        bridgeNode = network.createNode("bridgerule", allDBs);
      else
        bridgeNode = shouldCreate;
    } catch (NoSuchTypeException e) {
      // TODO Auto-generated catch block
      e.printStackTrace();
    }
    {
      if ("" != null)
        return bridgeNode;
    }
    throw new Error("Missing return statement in function");
  }

  final public HashMap<Node, Integer> bridgeExpressionList() throws ParseException {
    ArrayList<Node> nodes = new ArrayList<Node>();
    Node arg;
    ArrayList<String> attitudes = new ArrayList<String>();
    String attitude;
    jj_consume_token(32);
    arg = Expression();
    jj_consume_token(27);
    attitude = jj_consume_token(STRING).image;
    jj_consume_token(28);
    nodes.add(arg);
    attitudes.add(attitude.trim().toLowerCase());
    label_13: while (true) {
      switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
        case 27: {
          ;
          break;
        }
        default:
          jj_la1[48] = jj_gen;
          break label_13;
      }
      jj_consume_token(27);
      jj_consume_token(32);
      arg = Expression();
      jj_consume_token(27);
      attitude = jj_consume_token(STRING).image;
      jj_consume_token(28);
      nodes.add(arg);
      attitudes.add(attitude.trim().toLowerCase());
    }
    ArrayList<Integer> attitudeNo = new ArrayList<Integer>();
    for (String s : attitudes) {
      Integer num = controller.getAttitudeNumber(s);
      if (num == null) {
        if (true)
          throw new ParseException("No such attitude");
      }
      attitudeNo.add(num);
    }
    HashMap<Node, Integer> node_attitude = new HashMap<Node, Integer>();
    for (int i = 0; i < nodes.size(); i++) {
      node_attitude.put(nodes.get(i), attitudeNo.get(i));
    }
    {
      if ("" != null)
        return node_attitude;
    }
    throw new Error("Missing return statement in function");
  }

  final public void defineSemantic() throws ParseException, ParseException {
    String typeName;
    String superClass = null;
    jj_consume_token(83);
    typeName = jj_consume_token(STRING).image;
    jj_consume_token(84);
    switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
      case 83: {
        jj_consume_token(83);
        superClass = jj_consume_token(STRING).image;
        jj_consume_token(84);
        break;
      }
      default:
        jj_la1[49] = jj_gen;
        ;
    }
    typeName = typeName.trim();
    superClass = superClass.trim();

    if (network.getUserDefinedClasses().containsKey(typeName)) {
      if (true) {
        if (true)
          throw new ParseException("User Defined Class with the Same Name Already Exists.");
      }
    }

    while (true) {
      CLI.print("Create Custom Methods to Create Your Custom Class Using Command 'custom-method' ");
      String s = CLI.readInput();
      if (s.trim().toLowerCase().equals("done")) {
        try {
          network.createNewSemanticType(typeName, superClass, customMethods);
        } catch (Exception e) {
          // TODO Auto-generated catch block
          e.printStackTrace();
        }
        break;
      }
      MindGRAF_Parser parser = new MindGRAF_Parser(
          new StringReader(s));

      try {
        parser.customMethod();
      } catch (ParseException e) {
        System.out.println();
        System.out.println(e.getMessage());

        // TODO Auto-generated catch block

        continue;
      }
    }
  }

  final public void customMethod() throws ParseException, ParseException {
    String methodName = null;
    String returnType = null;
    ArrayList<String> params = new ArrayList<String>();
    ArrayList<String> args = new ArrayList<String>();
    String methodCode = null;
    jj_consume_token(85);
    jj_consume_token(83);
    methodName = jj_consume_token(STRING).image;
    jj_consume_token(84);
    jj_consume_token(83);
    params = methodParams();
    jj_consume_token(84);
    jj_consume_token(83);
    args = methodArgs();
    jj_consume_token(84);
    jj_consume_token(83);
    returnType = jj_consume_token(STRING).image;
    jj_consume_token(84);
    methodCode = methodCode();
    methodName = methodName.trim();
    returnType = returnType.trim();

    if (args.size() != params.size()) {
      if (true)
        throw new ParseException("args != params");
    }
    ArrayList<Class<?>> methodParams = new ArrayList<Class<?>>();
    CustomMethod customMethod = null;
    try {
      for (int i = 0; i < params.size(); i++)
        methodParams.add(Class.forName(params.get(i)));
      customMethod = new CustomMethod(methodName, methodCode, Class.forName(returnType), methodParams,
          args);
      customMethods.add(customMethod);
    } catch (ClassNotFoundException e) {
      // TODO: handle exception
    }
  }

  final public String methodCode() throws ParseException, ParseException {
    StringBuilder methodCodeBuilder = new StringBuilder();
    label_14: while (true) {
      switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
        case STRING: {
          jj_consume_token(STRING);
          break;
        }
        case 86: {
          jj_consume_token(86);
          break;
        }
        case 27: {
          jj_consume_token(27);
          break;
        }
        case 87: {
          jj_consume_token(87);
          break;
        }
        case 88: {
          jj_consume_token(88);
          break;
        }
        case 30: {
          jj_consume_token(30);
          break;
        }
        case 29: {
          jj_consume_token(29);
          break;
        }
        case 83: {
          jj_consume_token(83);
          break;
        }
        case 84: {
          jj_consume_token(84);
          break;
        }
        case 32: {
          jj_consume_token(32);
          break;
        }
        case 28: {
          jj_consume_token(28);
          break;
        }
        case 89: {
          jj_consume_token(89);
          break;
        }
        case 90: {
          jj_consume_token(90);
          break;
        }
        case 91: {
          jj_consume_token(91);
          break;
        }
        case 92: {
          jj_consume_token(92);
          break;
        }
        case 93: {
          jj_consume_token(93);
          break;
        }
        case 94: {
          jj_consume_token(94);
          break;
        }
        case 95: {
          jj_consume_token(95);
          break;
        }
        case 96: {
          jj_consume_token(96);
          break;
        }
        case 97: {
          jj_consume_token(97);
          break;
        }
        case 98: {
          jj_consume_token(98);
          break;
        }
        case 99: {
          jj_consume_token(99);
          break;
        }
        case 100: {
          jj_consume_token(100);
          break;
        }
        case 101: {
          jj_consume_token(101);
          break;
        }
        case 102: {
          jj_consume_token(102);
          break;
        }
        case VARIABLE: {
          jj_consume_token(VARIABLE);
          break;
        }
        case 103: {
          jj_consume_token(103);
          break;
        }
        case 104: {
          jj_consume_token(104);
          break;
        }
        case 105: {
          jj_consume_token(105);
          break;
        }
        case 106: {
          jj_consume_token(106);
          break;
        }
        case 25: {
          jj_consume_token(25);
          break;
        }
        case NUMBER: {
          jj_consume_token(NUMBER);
          break;
        }
        default:
          jj_la1[50] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
      }
      switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
        case NUMBER:
        case VARIABLE:
        case STRING:
        case 25:
        case 27:
        case 28:
        case 29:
        case 30:
        case 32:
        case 83:
        case 84:
        case 86:
        case 87:
        case 88:
        case 89:
        case 90:
        case 91:
        case 92:
        case 93:
        case 94:
        case 95:
        case 96:
        case 97:
        case 98:
        case 99:
        case 100:
        case 101:
        case 102:
        case 103:
        case 104:
        case 105:
        case 106: {
          ;
          break;
        }
        default:
          jj_la1[51] = jj_gen;
          break label_14;
      }
    }
    methodCodeBuilder.append(token.image);
    {
      if ("" != null)
        return methodCodeBuilder.toString();
    }
    throw new Error("Missing return statement in function");
  }

  final public ArrayList<String> methodArgs() throws ParseException, ParseException {
    ArrayList<String> allArgs = new ArrayList<String>();
    String arg;
    arg = methodArg();
    allArgs.add(arg);
    label_15: while (true) {
      switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
        case 27: {
          ;
          break;
        }
        default:
          jj_la1[52] = jj_gen;
          break label_15;
      }
      jj_consume_token(27);
      arg = methodArg();
      allArgs.add(arg);
    }
    {
      if ("" != null)
        return allArgs;
    }
    throw new Error("Missing return statement in function");
  }

  final public String methodArg() throws ParseException, ParseException {
    Token arg = null;
    switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
      case STRING: {
        arg = jj_consume_token(STRING);
        break;
      }
      case NUMBER: {
        arg = jj_consume_token(NUMBER);
        break;
      }
      default:
        jj_la1[53] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
    }
    String a = arg.image.trim();
    {
      if ("" != null)
        return a;
    }
    {
      if (true)
        throw new ParseException("Invalid argument");
    }
    throw new Error("Missing return statement in function");
  }

  final public ArrayList<String> methodParams() throws ParseException, ParseException {
    ArrayList<String> allParams = new ArrayList<String>();
    String arg;
    arg = methodParam();
    allParams.add(arg);
    label_16: while (true) {
      switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
        case 27: {
          ;
          break;
        }
        default:
          jj_la1[54] = jj_gen;
          break label_16;
      }
      jj_consume_token(27);
      arg = methodParam();
      allParams.add(arg);
    }
    {
      if ("" != null)
        return allParams;
    }
    throw new Error("Missing return statement in function");
  }

  final public String methodParam() throws ParseException, ParseException {
    Token param;
    param = jj_consume_token(STRING);
    String p = param.image.trim();
    {
      if ("" != null)
        return p;
    }
    throw new Error("Missing return statement in function");
  }

  final public void automaticHandling() throws ParseException, ParseException {
    switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
      case 107: {
        jj_consume_token(107);
        automaticHandling = true;
        break;
      }
      case 108: {
        jj_consume_token(108);
        automaticHandling = false;
        break;
      }
      default:
        jj_la1[55] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
    }
    CLI.print("Enable Cache?");
    System.out.print(":");
    while (true) {
      String input = CLI.readInput();
      if (input.trim().toLowerCase().equals("exit")) {
        System.out.println("Session ended.");
        CLI.loop = false;
      }
      MindGRAF_Parser parser = new MindGRAF_Parser(
          new StringReader(input.trim()));
      try {
        parser.EnableCache();
        break;
      } catch (ParseException e) {
        CLI.print("Wrong Command.");
        System.out.print(":");
      }
    }
  }

  final public void EnableCache() throws ParseException, ParseException {
    switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
      case 109: {
        jj_consume_token(109);
        cacheEnabled = true;
        break;
      }
      case 110: {
        jj_consume_token(110);
        cacheEnabled = false;
        break;
      }
      default:
        jj_la1[56] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
    }
    CLI.print("Enter Merge Function Number");
    System.out.print(":");
    while (true) {
      String input = CLI.readInput();
      if (input.trim().toLowerCase().equals("exit")) {
        System.out.println("Session ended.");
        CLI.loop = false;
      }
      MindGRAF_Parser parser = new MindGRAF_Parser(
          new StringReader(input.trim()));
      try {
        parser.MergeFunctionNumber();
        parser.MergeFunctionNumber();
        Set attitudeNames = new Set();
        attitudeNames.setSet(initialAttitudes);
        NetworkController.setUp(attitudeNames, consisAttitudeLists, uvbrEnabled, automaticHandling, cacheEnabled,
            mergeFN);
        break;
      } catch (ParseException e) {
        CLI.print("Wrong Command.");
        System.out.print(":");
      }
    }
  }

  final public void MergeFunctionNumber() throws ParseException, ParseException {
    String mfn;
    jj_consume_token(111);
    mfn = jj_consume_token(NUMBER).image;
    mergeFN = mergeFN = Integer.parseInt(mfn);
  }

  final public void UVBR() throws ParseException, ParseException {
    Token value;
    switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
      case 112: {
        jj_consume_token(112);
        uvbrEnabled = true;
        System.out.println("UVBR is ON");
        break;
      }
      case 113: {
        jj_consume_token(113);
        uvbrEnabled = false;
        System.out.println("UVBR is OFF");
        break;
      }
      default:
        jj_la1[57] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
    }
    Set attitudeNames = new Set();
    attitudeNames.setSet(initialAttitudes);
    CLI.print("Set Automatic Handling:");
    System.out.print(":");
    while (true) {
      String input = CLI.readInput();
      if (input.trim().toLowerCase().equals("exit")) {
        System.out.println("Session ended.");
        CLI.loop = false;
      }
      MindGRAF_Parser parser = new MindGRAF_Parser(
          new StringReader(input.trim()));
      try {
        parser.automaticHandling();
        break;
      } catch (ParseException e) {
        CLI.print("Wrong Command.");
        System.out.print(":");
      }
    }
  }

  final public void setAttitudes() throws ParseException, ParseException {
    initialAttitudes.put("belief", 0);
    switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
      case 114: {
        jj_consume_token(114);
        jj_consume_token(32);
        attitude();
        label_17: while (true) {
          switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
            case 27: {
              ;
              break;
            }
            default:
              jj_la1[58] = jj_gen;
              break label_17;
          }
          jj_consume_token(27);
          attitude();
        }
        jj_consume_token(28);
        System.out.println("Attitudes Defined:");
        for (String key : initialAttitudes.keySet()) {
          System.out.println(key);
        }
        break;
      }
      case N: {
        jj_consume_token(N);
        break;
      }
      default:
        jj_la1[59] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
    }
  }

  final public void defineContext() throws ParseException, ParseException {
    String CName;
    jj_consume_token(115);
    jj_consume_token(83);
    CName = jj_consume_token(STRING).image;
    jj_consume_token(84);
    CName = CName.trim().toLowerCase();
    try {
      controller.createNewContext(CName);
      CLI.print("Context " + CName + " is Created.");

    } catch (Exception e) {
      CLI.print(e.getMessage());
    }
  }

  final public void wffAttitudeSet() throws ParseException, ParseException {
    jj_consume_token(32);
    jj_consume_token(WFF_NAME);
    jj_consume_token(27);
    jj_consume_token(STRING);
    jj_consume_token(28);
  }

  final public void attitude() throws ParseException, ParseException {
    Token attitude;
    attitude = jj_consume_token(STRING);
    String a = attitude.image.trim().toLowerCase();
    if (initialAttitudes.containsKey(a)) {
      if (true)
        throw new ParseException("duplicate attitudes");
    }
    initialAttitudes.put(a, attitudeNumber);
    attitudeNumber++;
  }

  final public void TelescopableAttitudes() throws ParseException, ParseException {
    ArrayList<Integer> list = new ArrayList<Integer>();
    jj_consume_token(116);
    switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
      case 32: {
        list = telescopableAttitudeList();
        break;
      }
      default:
        jj_la1[60] = jj_gen;
        ;
    }
    finalTelList = list;
    for (Integer in : list) {
      System.out.print(in + " ");
      System.out.println(); // Move to the next line after printing each inner list
    }
  }

  final public ArrayList<Integer> telescopableAttitudeList() throws ParseException, ParseException {
    Token attitude;
    ArrayList<Integer> telList = new ArrayList<Integer>();
    Integer att;
    jj_consume_token(32);
    att = OneAttitudeInList();
    telList.add(att);
    label_18: while (true) {
      switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
        case 27: {
          ;
          break;
        }
        default:
          jj_la1[61] = jj_gen;
          break label_18;
      }
      jj_consume_token(27);
      att = OneAttitudeInList();
      telList.add(att);
    }
    jj_consume_token(28);
    {
      if ("" != null)
        return telList;
    }
    throw new Error("Missing return statement in function");
  }

  final public Integer OneAttitudeInList() throws ParseException, ParseException {
    Token attitude;
    attitude = jj_consume_token(STRING);
    String s = attitude.image.trim().toLowerCase();
    if (!initialAttitudes.containsKey(s)) {
      if (true)
        throw new ParseException("Not in initially Defined Attitudes");
    }

    {
      if ("" != null)
        return initialAttitudes.get(s);
    }
    throw new Error("Missing return statement in function");
  }

  final public void underConsequenceAttitudes() throws ParseException, ParseException {
    ArrayList<Integer> list = new ArrayList<Integer>();
    jj_consume_token(117);
    switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
      case 32: {
        list = consequenceAttitudeList();
        break;
      }
      default:
        jj_la1[62] = jj_gen;
        ;
    }
    finalConseqList = list;
    for (Integer in : list) {
      System.out.print(in + " ");
      System.out.println(); // Move to the next line after printing each inner list
    }
  }

  final public ArrayList<Integer> consequenceAttitudeList() throws ParseException, ParseException {
    Token attitude;
    ArrayList<Integer> conseqList = new ArrayList<Integer>();
    Integer att;
    jj_consume_token(32);
    att = OneAttitudeInList();
    conseqList.add(att);
    label_19: while (true) {
      switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
        case 27: {
          ;
          break;
        }
        default:
          jj_la1[63] = jj_gen;
          break label_19;
      }
      jj_consume_token(27);
      att = OneAttitudeInList();
      conseqList.add(att);
    }
    jj_consume_token(28);
    {
      if ("" != null)
        return conseqList;
    }
    throw new Error("Missing return statement in function");
  }

  final public void underConjunctionAttitudes() throws ParseException, ParseException {
    ArrayList<Integer> list = new ArrayList<Integer>();
    jj_consume_token(118);
    switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
      case 32: {
        list = conjunctionAttitudeList();
        break;
      }
      default:
        jj_la1[64] = jj_gen;
        ;
    }
    finalConjList = list;
    for (Integer in : list) {
      System.out.print(in + " ");
      System.out.println(); // Move to the next line after printing each inner list
    }
  }

  final public ArrayList<Integer> conjunctionAttitudeList() throws ParseException, ParseException {
    Token attitude;
    ArrayList<Integer> conjList = new ArrayList<Integer>();
    Integer att;
    jj_consume_token(32);
    att = OneAttitudeInList();
    conjList.add(att);
    label_20: while (true) {
      switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
        case 27: {
          ;
          break;
        }
        default:
          jj_la1[65] = jj_gen;
          break label_20;
      }
      jj_consume_token(27);
      att = OneAttitudeInList();
      conjList.add(att);
    }
    jj_consume_token(28);
    {
      if ("" != null)
        return conjList;
    }
    throw new Error("Missing return statement in function");
  }

  final public void consistentAttitudes() throws ParseException, ParseException {
    jj_consume_token(119);
    label_21: while (true) {
      consisAttitudeList();
      switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
        case 32: {
          ;
          break;
        }
        default:
          jj_la1[66] = jj_gen;
          break label_21;
      }
    }
    for (ArrayList<Integer> list : consisAttitudeLists) {
      for (Integer num : list) {
        System.out.print(num + " ");
      }
      System.out.println(); // Move to the next line after printing each inner list
    }
  }

  final public void consisAttitudeList() throws ParseException, ParseException {
    Token attitude;
    jj_consume_token(32);
    OneAttitudeInConsisList();
    label_22: while (true) {
      switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
        case 27: {
          ;
          break;
        }
        default:
          jj_la1[67] = jj_gen;
          break label_22;
      }
      jj_consume_token(27);
      OneAttitudeInConsisList();
    }
    jj_consume_token(28);
    ArrayList<Integer> finalConsisList = new ArrayList<Integer>();
    for (int i = 0; i < consisAttitudeList.size(); i++) {
      finalConsisList.add(consisAttitudeList.get(i));
    }

    consisAttitudeLists.add(finalConsisList);
    consisAttitudeList.clear();

    System.out.println("now printing all contents:");

    for (ArrayList<Integer> list : consisAttitudeLists) {
      for (Integer num : list) {
        System.out.print(num + " ");
      }
      System.out.println(); // Move to the next line after printing each inner list
    }
    System.out.print(consisAttitudeList.size() + " the size..");
    System.out.println(consisAttitudeList.size() + " the size..");
    System.out.println(finalConsisList.size() + " the size of the final list");
  }

  final public void OneAttitudeInConsisList() throws ParseException, ParseException {
    Token attitude;
    attitude = jj_consume_token(STRING);
    String s = attitude.image.trim().toLowerCase();
    if (!initialAttitudes.containsKey(s)) {
      if (true)
        throw new ParseException("Not in initially Defined Attitudes");
    }
    currConsisAttitude = initialAttitudes.get(s);
    consisAttitudeList.add(currConsisAttitude);
  }

  /** Generated Token Manager. */
  public MindGRAF_ParserTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[68];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static private int[] jj_la1_3;
  static {
    jj_la1_init_0();
    jj_la1_init_1();
    jj_la1_init_2();
    jj_la1_init_3();
  }

  private static void jj_la1_init_0() {
    jj_la1_0 = new int[] { 0x70c8000, 0x8000, 0x6008000, 0x8000000, 0x0, 0x8000000, 0x800000, 0x800000, 0x8000000,
        0x8000000, 0x8000000, 0x0, 0x800000, 0x8000000, 0x8000000, 0x8000000, 0x8000000, 0x8000000, 0x8000000, 0x200000,
        0x78c8000, 0x8000000, 0x7c0, 0x7c0, 0x0, 0x0, 0x0, 0x800000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8000000, 0x0, 0x7aa00020, 0x7aa00020, 0x8000000, 0x800020,
        0x8000000, 0x0, 0x0, 0x0, 0x8000000, 0x800, 0x0, 0x8000000, 0x0, 0x8000000, 0x0, 0x8000000, 0x0, 0x8000000, };
  }

  private static void jj_la1_init_1() {
    jj_la1_1 = new int[] { 0x1, 0x1, 0x1, 0x0, 0xfe0002, 0x0, 0x4, 0x4, 0x0, 0x0, 0x0, 0xfff8, 0x4, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0xff010000, 0xfe0002, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x1, 0x0, 0x1, 0x0, 0x1, 0x0, 0x1, 0x0, };
  }

  private static void jj_la1_init_2() {
    jj_la1_2 = new int[] { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x7fe0f, 0x0, 0x80, 0x100, 0x0, 0x80, 0x100, 0x80, 0x100, 0x80, 0x100, 0x80, 0x100,
        0x80, 0x100, 0x80, 0x100, 0x80, 0x100, 0x80, 0x100, 0x80, 0x100, 0x80, 0x100, 0x0, 0x80000, 0xffd80000,
        0xffd80000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, };
  }

  private static void jj_la1_init_3() {
    jj_la1_3 = new int[] { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x80000, 0x80000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7ff, 0x7ff, 0x0, 0x0, 0x0, 0x1800, 0x6000, 0x30000,
        0x0, 0x40000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, };
  }

  /** Constructor with InputStream. */
  public MindGRAF_Parser(java.io.InputStream stream) {
    this(stream, null);
  }

  /** Constructor with InputStream and supplied encoding */
  public MindGRAF_Parser(java.io.InputStream stream, String encoding) {
    try {
      jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1);
    } catch (java.io.UnsupportedEncodingException e) {
      throw new RuntimeException(e);
    }
    token_source = new MindGRAF_ParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 68; i++)
      jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
    ReInit(stream, null);
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try {
      jj_input_stream.ReInit(stream, encoding, 1, 1);
    } catch (java.io.UnsupportedEncodingException e) {
      throw new RuntimeException(e);
    }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 68; i++)
      jj_la1[i] = -1;
  }

  /** Constructor. */
  public MindGRAF_Parser(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new MindGRAF_ParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 68; i++)
      jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    if (jj_input_stream == null) {
      jj_input_stream = new SimpleCharStream(stream, 1, 1);
    } else {
      jj_input_stream.ReInit(stream, 1, 1);
    }
    if (token_source == null) {
      token_source = new MindGRAF_ParserTokenManager(jj_input_stream);
    }

    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 68; i++)
      jj_la1[i] = -1;
  }

  /** Constructor with generated Token Manager. */
  public MindGRAF_Parser(MindGRAF_ParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 68; i++)
      jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(MindGRAF_ParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 68; i++)
      jj_la1[i] = -1;
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null)
      token = token.next;
    else
      token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  /** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null)
      token = token.next;
    else
      token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

  /** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null)
        t = t.next;
      else
        t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk_f() {
    if ((jj_nt = token.next) == null)
      return (jj_ntk = (token.next = token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[120];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 68; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1 << j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1 << j)) != 0) {
            la1tokens[32 + j] = true;
          }
          if ((jj_la1_2[i] & (1 << j)) != 0) {
            la1tokens[64 + j] = true;
          }
          if ((jj_la1_3[i] & (1 << j)) != 0) {
            la1tokens[96 + j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 120; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  private boolean trace_enabled;

  /** Trace enabled. */
  final public boolean trace_enabled() {
    return trace_enabled;
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

}
