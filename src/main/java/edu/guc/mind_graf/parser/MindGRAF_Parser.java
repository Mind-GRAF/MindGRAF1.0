/* MindGRAF_Parser.java */
/* Generated By:JavaCC: Do not edit this line. MindGRAF_Parser.java */
package edu.guc.mind_graf.parser;
import edu.guc.mind_graf.context.ContextController;
import edu.guc.mind_graf.components.CustomMethod;

import java.util.ArrayList;
import java.util.HashMap;
import java.io.StringReader;
import edu.guc.mind_graf.nodes.ActNode;
import edu.guc.mind_graf.set.NodeSet;
import edu.guc.mind_graf.set.Set;
import java.util.HashSet;
import edu.guc.mind_graf.cables.DownCable;
import edu.guc.mind_graf.cables.DownCableSet;
import edu.guc.mind_graf.caseFrames.Adjustability;
import edu.guc.mind_graf.context.Context;
import java.util.Collection;
import java.util.Collections;
import edu.guc.mind_graf.exceptions.NoSuchTypeException;
import edu.guc.mind_graf.exceptions.DirectCycleException;
import edu.guc.mind_graf.exceptions.NoPlansExistForTheActException;
import edu.guc.mind_graf.network.Network;
import edu.guc.mind_graf.nodes.Node;
import edu.guc.mind_graf.relations.Relation;
import edu.guc.mind_graf.nodes.PropositionNode;

public class MindGRAF_Parser implements MindGRAF_ParserConstants {
      private ContextController controller = new ContextController();
      private static int  mode = 1;
      static boolean uvbrEnabled;
      private Network network = controller.getNetwork();

      //setting the attitudes 
      private static int attitudeNumber = 1;
      private static HashMap<String, Integer> initialAttitudes = new HashMap<String, Integer>();

     //setting the consistent attitudes
      private static ArrayList<ArrayList<Integer>> consisAttitudeLists = new ArrayList<ArrayList<Integer>>();
      private  static ArrayList<Integer> consisAttitudeList = new ArrayList<Integer>();
      private static int currConsisAttitude;
      //setting closed under conjunction Attitudes
      private static ArrayList<Integer> finalConjList;

      //setting closed under consequence Attitudes
      private  static ArrayList<Integer> finalConseqList;

       //setting telescopable Attitudes
        private  static ArrayList<Integer> finalTelList;

      //creation of nodes
        //private static ArrayList<Node> molecNodes = new ArrayList<Node>();
        private static HashMap<String, DownCable> allDCB = new HashMap<String, DownCable>();

      //case frames
      private static ArrayList<ArrayList<String>> caseFrames = new ArrayList<ArrayList<String>>();

      // semantic type
      private static ArrayList<CustomMethod> customMethods = new ArrayList<CustomMethod>();


      //forall
      private static HashMap<String,Node> varNodesForall = new HashMap<String,Node>();

      // wffs
      private static HashMap<Integer, ArrayList<String>> wffs = new HashMap<Integer, ArrayList<String>>();
      private static Integer wffCount = 1;

      //default attitude
      private static Integer defaultAttitude = 0;


    public static <K, V> HashMap<V, ArrayList<K>> groupByValue(HashMap<K, V> originalMap) {
    HashMap<V, ArrayList<K>> groupedMap = new HashMap<>();
    for (HashMap.Entry<K, V> entry : originalMap.entrySet()) {
        V value = entry.getValue();
        ArrayList<K> keys = groupedMap.get(value);
        if (keys == null) {
            keys = new ArrayList<>();
            groupedMap.put(value, keys);
        }
        keys.add(entry.getKey());
    }
    return groupedMap;
}



        @SuppressWarnings("static-access")
        public static void removeDuplicates(ArrayList<String> list) {
        HashSet<String> set = new HashSet<>();
        for (int i = 0; i < list.size(); i++) {
            String str = list.get(i);
            if (!set.add(str)) { // If adding the string returns false, it's a duplicate
                list.remove(i); // Remove the duplicate string
                i--; // Decrement i to adjust for the removed element
            }
        }
    }

  public static int indexOfList(ArrayList<ArrayList<String>> listOfLists, ArrayList<String> listToAdd) {
    // Iterate over the listOfLists and compare each inner list with listToAdd
    for (int i = 0; i < listOfLists.size(); i++) {
      ArrayList<String> currentList = listOfLists.get(i);
      if (areListsEqual(currentList, listToAdd)) {
        return i; // If found, return the index
      }
    }
    return -1; // If not found, return -1
  }

  private static boolean areListsEqual(ArrayList<String> list1, ArrayList<String> list2) {
    // Check if the lists have the same size
    if (list1.size() != list2.size()) {
      return false;
    }
    // Check if the elements in list1 exist in list2
    for (String element : list1) {
      if (!list2.contains(element)) {
        return false;
      }
    }
    // Check if the elements in list2 exist in list1
    for (String element : list2) {
      if (!list1.contains(element)) {
        return false;
      }
    }
    // If all elements are found in both lists, they are equal
    return true;
  }
  public Node compareMolecularNode(DownCableSet dcs) {
    Node returnNode = null;
    for (Node nn : network.getNodes().values()) {
      DownCableSet downc = nn.getDownCableSet();
      if (downc != null) {
        String key = downc.getMolecularSetKey();
        if (key.equals(dcs.getMolecularSetKey())) {
          returnNode = nn;
          Collection<DownCable> dcCollection = downc.getValues();
          for (DownCable d : dcCollection) {
            String relName = d.getRelation().getName();
            ArrayList<String> firstNs = d.getNodeSet().getNames();
            ArrayList<String> ns = dcs.get(relName).getNodeSet().getNames();
            if (!firstNs.equals(ns))
              return null;
          }
          break;
        }
      }
    }
    return returnNode;

  }

  public static void main(String[] args) throws ParseException {
    // Instantiate the parser
    MindGRAF_Parser parser = new MindGRAF_Parser(System.in);
   /* try {
      // Start parsing
      parser.Start();

      System.out.println("Parsing successful!");
    } catch (ParseException e) {
      // Handle parsing errors
      System.err.println("Parsing failed: " + e.getMessage());
    }*/
  }

// Define the grammar
  final public 
Node Expression() throws ParseException, ParseException {Node result = null;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case PREDICATE_NAME_BRACKET:{
      result = Predicate();
      break;
      }
    case ANDOR_THRESH:{
      result = AndOrThreshExpression(false);
      break;
      }
    case 30:{
      result = OrAndEntailment(false);
      break;
      }
    case QUANTIFIER:{
      result = forall();
      break;
      }
    case WHENDO_DOIF:{
      result = WhenIfDo();
      break;
      }
    case 24:{
      result = gradedProp();
      break;
      }
    case 23:{
      result = negatedProp();
      break;
      }
    default:
      jj_la1[0] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
{if ("" != null) return result;}
    throw new Error("Missing return statement in function");
}

  final public Node andOrThreshEnt() throws ParseException, ParseException {Node arg;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case ANDOR_THRESH:{
      arg = AndOrThreshExpression(true);
      break;
      }
    case 30:{
      arg = OrAndEntailment(true);
      break;
      }
    default:
      jj_la1[1] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
{if ("" != null) return arg;}
    throw new Error("Missing return statement in function");
}

  final public Node negatedAndOrThreshEnt() throws ParseException, ParseException {Node node = null;
    jj_consume_token(23);
    node = andOrThreshEnt();
Node negatedNode = null;
      try {
         negatedNode = node.createNegation(node);
      } catch (NoSuchTypeException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
      }
    {if ("" != null) return negatedNode;}
    throw new Error("Missing return statement in function");
}

  final public Node gradedAndOrThreshEnt() throws ParseException {Node node = null;
  String gradeValue = null;
    jj_consume_token(24);
    node = andOrThreshEnt();
    jj_consume_token(25);
    gradeValue = jj_consume_token(NUMBER).image;
    jj_consume_token(26);
gradeValue = gradeValue.trim();
    // Relations
    Relation grade = network.getRelations().get("grade");
    Relation prop = network.getRelations().get("prop");

    // nodes
    Node gradeNode = null;
    Node molecNode = null;
    try {
      gradeNode = network.createNode(gradeValue, "individualnode");
      // cables
      DownCable gradeDC = new DownCable(grade, new NodeSet(gradeNode));
      DownCable propDC = new DownCable(prop, new NodeSet(node));
      DownCableSet alldcs = new DownCableSet(gradeDC, propDC);
      Node shouldCreate = compareMolecularNode(alldcs);
      if (shouldCreate == null)
        molecNode = network.createNode("propositionnode", alldcs);
      else
        molecNode = shouldCreate;
    } catch (NoSuchTypeException e) {
      // TODO Auto-generated catch block
      e.printStackTrace();
    }
    {if ("" != null) return molecNode;}
    throw new Error("Missing return statement in function");
}

  final public Node ForallExpressionList() throws ParseException, ParseException {Node arg;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case ANDOR_THRESH:
    case 30:{
      arg = andOrThreshEnt();
      break;
      }
    case 24:{
      arg = gradedAndOrThreshEnt();
      break;
      }
    case 23:{
      arg = negatedAndOrThreshEnt();
{if ("" != null) return arg;}
      break;
      }
    default:
      jj_la1[2] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
}

  final public Node forall() throws ParseException, ParseException {Node arg = null;
  ArrayList<Node> varNodes = new ArrayList<Node>();
    jj_consume_token(QUANTIFIER);
    varNodes = variableNodes();
HashMap<String, Node> nodeSet = new HashMap<String, Node>();
    for (Node n : varNodes)
      nodeSet.put(n.getName(), n);

    varNodesForall = nodeSet;
    jj_consume_token(27);
    jj_consume_token(28);
    arg = ForallExpressionList();
    jj_consume_token(27);
{if ("" != null) return arg;}
    throw new Error("Missing return statement in function");
}

  final public ArrayList<Node> variableNodes() throws ParseException, ParseException {Node varNode = null;
  String var = null;
  ArrayList<Node>varNodes = new ArrayList<Node>();
    var = jj_consume_token(STRING).image;
String s = var.trim().toLowerCase();
    try {
      varNodes.add(network.createVariableNode(s, "propositionnode"));
    } catch (NoSuchTypeException e) {
      // TODO Auto-generated catch block
      e.printStackTrace();
    }
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case 25:{
        ;
        break;
        }
      default:
        jj_la1[3] = jj_gen;
        break label_1;
      }
      jj_consume_token(25);
      var = jj_consume_token(STRING).image;
String ss = var.trim().toLowerCase();
    try {
      varNodes.add(network.createVariableNode(ss, "propositionnode"));
    } catch (NoSuchTypeException e) {
      // TODO Auto-generated catch block
      e.printStackTrace();
    }
    }
{if ("" != null) return varNodes;}
    throw new Error("Missing return statement in function");
}

  final public Node WhenIfDo() throws ParseException, ParseException {Node prop = null;
  Node actNode = null;
  String attitude;
  String ruleType;
    ruleType = jj_consume_token(WHENDO_DOIF).image;
    prop = Expression();
    jj_consume_token(25);
    attitude = jj_consume_token(STRING).image;
    jj_consume_token(26);
    jj_consume_token(29);
    jj_consume_token(30);
    actNode = Act();
    jj_consume_token(26);
ruleType = ruleType.trim().toLowerCase();
    ruleType = ruleType.substring(0, ruleType.length() - 1);
    attitude = attitude.trim().toLowerCase();
    Integer attNum = controller.getAttitudeNumber(attitude);
    if (attNum == null)
      {if (true) throw new ParseException("No such attitude.");}

    Relation doRel = network.getRelations().get("do");
    DownCable doDC = new DownCable(doRel, new NodeSet(actNode));
    if (ruleType.equals("whendo")) {
      // creating when do relations
      Relation whenRel = network.createRelation(attNum + "-when", "propositionnode", Adjustability.NONE, 0);
      // downcable
      DownCable whenDC = new DownCable(whenRel, new NodeSet(prop));

      DownCableSet whenDoDC = new DownCableSet(whenDC, doDC);
      // creating whenDo Rule Node
      Node shouldCreate = compareMolecularNode(whenDoDC);
      Node whenDoNode = null;
      try {
        if (shouldCreate == null)
          whenDoNode = network.createNode("propositionnode", whenDoDC);
        else
          whenDoNode = shouldCreate;
      } catch (NoSuchTypeException e) {
        // TODO: handle exception
      }
      {if ("" != null) return whenDoNode;}

    } else {
      // creating do if relations
      Relation ifRel = network.createRelation(attNum + "-if", "propositionnode", Adjustability.NONE, 0);

      // downcable
      DownCable ifDC = new DownCable(ifRel, new NodeSet(prop));

      DownCableSet ifDoDC = new DownCableSet(ifDC, doDC);
      // creating whenDo Rule Node
      Node shouldCreate = compareMolecularNode(ifDoDC);
      Node ifDoNode = null;
      try {
        if (shouldCreate == null)
          ifDoNode = network.createNode("propositionnode", ifDoDC);
        else
          ifDoNode = shouldCreate;
      } catch (NoSuchTypeException e) {
        // TODO: handle exception
      }
      {if ("" != null) return ifDoNode;}

    }
    throw new Error("Missing return statement in function");
}

  final public Node Act() throws ParseException, ParseException {Node act = null;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case 31:{
      act = SNSequence();
      break;
      }
    case 32:{
      act = Attitude();
      break;
      }
    case 33:{
      act = Achieve();
      break;
      }
    case 34:{
      act = DoOne();
      break;
      }
    case 35:{
      act = DoAll();
      break;
      }
    case 36:{
      act = GuardedAct();
      break;
      }
    case 37:{
      act = SNIF();
      break;
      }
    case 38:{
      act = SNIterate();
      break;
      }
    default:
      jj_la1[4] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
{if ("" != null) return act;}
{if (true) throw new ParseException("No valid action found.");}
    throw new Error("Missing return statement in function");
}

  final public Node SNSequence() throws ParseException, ParseException {Node actNodeOne = null;
  Node actNodeTwo = null;
    jj_consume_token(31);
    actNodeOne = Act();
    jj_consume_token(25);
    actNodeTwo = Act();
    jj_consume_token(26);
// relations
    Relation obj1 = network.createRelation("obj1", "actnode", Adjustability.NONE, 1);
    Relation obj2 = network.createRelation("obj2", "actnode", Adjustability.NONE, 1);
    Relation action = network.getRelations().get("action");
    Node snSeqIndividual = null;
    Node snsequenceNode = null;
    try {
      // individual node
      snSeqIndividual = network.createNode("snsequence", "individualnode");
      // Cables
      DownCable actionDC = new DownCable(action, new NodeSet(snSeqIndividual));
      DownCable obj1DC = new DownCable(obj1, new NodeSet(actNodeOne));
      DownCable obj2DC = new DownCable(obj2, new NodeSet(actNodeTwo));
      DownCableSet alldcs = new DownCableSet(actionDC, obj1DC, obj2DC);
      // snsequence act node creation
      Node shouldCreate = compareMolecularNode(alldcs);
      if(shouldCreate == null)
        snsequenceNode = network.createNode("actnode", new DownCableSet(actionDC, obj1DC, obj2DC));
      else
        snsequenceNode = shouldCreate;
    } catch (NoSuchTypeException e) {
      // TODO Auto-generated catch block
      e.printStackTrace();
    }
    {if ("" != null) return snsequenceNode;}
    throw new Error("Missing return statement in function");
}

  final public Node Attitude() throws ParseException, ParseException {Node prop = null;
    jj_consume_token(32);
    prop = Expression();
    jj_consume_token(26);
// relations
    Relation action = network.getRelations().get("action");
    Relation obj = network.getRelations().get("obj");

    // attitude indiv node
    Node attitudeIndividual = null;
    Node attitudeActNode = null;
    try {
      attitudeIndividual = network.createNode("attitude", "individualnode");

      // cables
      DownCable objDC = new DownCable(obj, new NodeSet(prop));
      DownCable actionDC = new DownCable(action, new NodeSet(attitudeIndividual));
      DownCableSet alldcs = new DownCableSet(objDC, actionDC);
      // attitude act node
      Node shouldCreate = compareMolecularNode(alldcs);
      if(shouldCreate == null)
        attitudeActNode = network.createNode("actnode", new DownCableSet(objDC, actionDC));
      else
        attitudeActNode = shouldCreate;

    } catch (NoSuchTypeException e) {
      // TODO Auto-generated catch block
      e.printStackTrace();
    }
    {if ("" != null) return attitudeActNode;}
    throw new Error("Missing return statement in function");
}

  final public Node Achieve() throws ParseException, ParseException {Node prop = null;
    jj_consume_token(33);
    prop = Expression();
    jj_consume_token(26);
// relations
    Relation action = network.getRelations().get("action");
    Relation obj = network.getRelations().get("obj");

    // believe indiv node
    Node achieveIndividual = null;
    Node achieveActNode = null;
    try {
      achieveIndividual = network.createNode("achieve", "individualnode");

      // cables
      DownCable objDC = new DownCable(obj, new NodeSet(prop));
      DownCable actionDC = new DownCable(action, new NodeSet(achieveIndividual));
      DownCableSet alldcs = new DownCableSet(objDC, actionDC);
      // achieve act node
      Node shouldCreate = compareMolecularNode(alldcs);
      if(shouldCreate == null)
        achieveActNode = network.createNode("actnode", new DownCableSet(objDC, actionDC));
      else
        achieveActNode = shouldCreate;

    } catch (NoSuchTypeException e) {
      // TODO Auto-generated catch block
      e.printStackTrace();
    }
    {if ("" != null) return achieveActNode;}
    throw new Error("Missing return statement in function");
}

  final public Node DoOne() throws ParseException, ParseException {HashMap<String, Node> hashedNodes = new HashMap<String, Node>();
  Node oneAct;
    jj_consume_token(34);
    oneAct = Act();
hashedNodes.put(oneAct.getName(),oneAct);
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case 25:{
        ;
        break;
        }
      default:
        jj_la1[5] = jj_gen;
        break label_2;
      }
      jj_consume_token(25);
      oneAct = Act();
hashedNodes.put(oneAct.getName(),oneAct);
    }
    jj_consume_token(26);
// relations
    Relation action = network.getRelations().get("action");
    Relation obj = network.getRelations().get("obj");

    // dooneIndividual
    Node doOneIndiv = null;
    Node doOneActNode = null;
    try {
      doOneIndiv = network.createNode("doone", "individualnode");
      //cables
      DownCable actionDC = new DownCable(action, new NodeSet(doOneIndiv));
      DownCable objDC = new DownCable(obj, new NodeSet(hashedNodes));
      DownCableSet allCables = new DownCableSet(actionDC, objDC);
      Node shouldCreate = compareMolecularNode(allCables);
      if(shouldCreate == null)
        doOneActNode = network.createNode("actnode", allCables);
      else
        doOneActNode = shouldCreate;
    } catch (NoSuchTypeException e) {
      // TODO Auto-generated catch block
      e.printStackTrace();
    }
    {if ("" != null) return doOneActNode;}
    throw new Error("Missing return statement in function");
}

  final public Node DoAll() throws ParseException, ParseException {HashMap<String, Node> hashedNodes = new HashMap<String, Node>();
  Node oneAct;
    jj_consume_token(35);
    oneAct = Act();
hashedNodes.put(oneAct.getName(),oneAct);
    label_3:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case 25:{
        ;
        break;
        }
      default:
        jj_la1[6] = jj_gen;
        break label_3;
      }
      jj_consume_token(25);
      oneAct = Act();
hashedNodes.put(oneAct.getName(),oneAct);
    }
    jj_consume_token(26);
// relations
    Relation action = network.getRelations().get("action");
    Relation obj = network.getRelations().get("obj");

    // doAllIndividual
    Node doAllIndiv = null;
    Node doAllActNode = null;
    try {
      doAllIndiv = network.createNode("doall", "individualnode");
      //cables
      DownCable actionDC = new DownCable(action, new NodeSet(doAllIndiv));
      DownCable objDC = new DownCable(obj, new NodeSet(hashedNodes));
      DownCableSet allCables = new DownCableSet(actionDC, objDC);
      Node shouldCreate = compareMolecularNode(allCables);
      if(shouldCreate == null)
        doAllActNode = network.createNode("actnode", allCables);
      else
        doAllActNode = shouldCreate;
    } catch (NoSuchTypeException e) {
      // TODO Auto-generated catch block
      e.printStackTrace();
    }
    {if ("" != null) return doAllActNode;}
    throw new Error("Missing return statement in function");
}

  final public Node GuardedAct() throws ParseException, ParseException {Node actNode = null;
  Node prop = null;
    jj_consume_token(36);
    actNode = Act();
    jj_consume_token(25);
    prop = Expression();
    jj_consume_token(26);
// Relations
    Relation actRel = network.createRelation("act", "actnode", Adjustability.NONE, 1);
    Relation guardRel = network.createRelation("guard", "propositionnode", Adjustability.NONE, 1);

    // cables
    DownCable actDC = new DownCable(actRel, new NodeSet(actNode));
    DownCable guardDC = new DownCable(guardRel, new NodeSet(prop));

    DownCableSet allcables = new DownCableSet(actDC, guardDC);
    // creating guarded actnode
    Node guardedActNode = null;
    Node shouldCreate = compareMolecularNode(allcables);
    try {
      if (shouldCreate == null)
        guardedActNode = network.createNode("actnode", allcables);
      else
        guardedActNode = shouldCreate;
    } catch (NoSuchTypeException e) {
      // TODO Auto-generated catch block
      e.printStackTrace();
    }
    {if ("" != null) return guardedActNode;}
    throw new Error("Missing return statement in function");
}

  final public Node SNIF() throws ParseException, ParseException {Node oneGuardAct = null;
  HashMap<String,Node> allGuardActs = new HashMap<String, Node>();
    jj_consume_token(37);
    oneGuardAct = GuardedAct();
allGuardActs.put(oneGuardAct.getName(),oneGuardAct);
    label_4:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case 25:{
        ;
        break;
        }
      default:
        jj_la1[7] = jj_gen;
        break label_4;
      }
      jj_consume_token(25);
      oneGuardAct = GuardedAct();
allGuardActs.put(oneGuardAct.getName(),oneGuardAct);
    }
    jj_consume_token(26);
// relations
    Relation action = network.getRelations().get("action");
    Relation obj = network.getRelations().get("obj");

    // snif indiv node
    Node snifIndividual = null;
    Node snifActNode = null;
    try {
      snifIndividual = network.createNode("snif", "individualnode");
      //cables
       DownCable actionDC = new DownCable(action, new NodeSet(snifIndividual));
       DownCable objDC = new DownCable(obj, new NodeSet(allGuardActs));
       DownCableSet allCables = new DownCableSet(actionDC, objDC);

       //creating snif act node
       Node shouldCreate = compareMolecularNode(allCables);
       if(shouldCreate == null)
        snifActNode = network.createNode("actnode", allCables);
       else
        snifActNode = shouldCreate;
    } catch (NoSuchTypeException e) {
      // TODO Auto-generated catch block
      e.printStackTrace();
    }
    {if ("" != null) return snifActNode;}
    throw new Error("Missing return statement in function");
}

  final public Node SNIterate() throws ParseException, ParseException {Node oneGuardAct = null;
  HashMap<String,Node> allGuardActs = new HashMap<String, Node>();
    jj_consume_token(38);
    oneGuardAct = GuardedAct();
allGuardActs.put(oneGuardAct.getName(),oneGuardAct);
    label_5:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case 25:{
        ;
        break;
        }
      default:
        jj_la1[8] = jj_gen;
        break label_5;
      }
      jj_consume_token(25);
      oneGuardAct = GuardedAct();
allGuardActs.put(oneGuardAct.getName(),oneGuardAct);
    }
    jj_consume_token(26);
// relations
    Relation action = network.getRelations().get("action");
    Relation obj = network.getRelations().get("obj");

    // sniterate indiv node
    Node sniterateIndividual = null;
    Node sniterateActNode = null;
    try {
      sniterateIndividual = network.createNode("sniterate", "individualnode");
      //cables
       DownCable actionDC = new DownCable(action, new NodeSet(sniterateIndividual));
       DownCable objDC = new DownCable(obj, new NodeSet(allGuardActs));
       DownCableSet allCables = new DownCableSet(actionDC, objDC);

       //creating sniterate act node
       Node shouldCreate = compareMolecularNode(allCables);
       if(shouldCreate == null)
        sniterateActNode = network.createNode("actnode", allCables);
       else
        sniterateActNode = shouldCreate;
    } catch (NoSuchTypeException e) {
      // TODO Auto-generated catch block
      e.printStackTrace();
    }
    {if ("" != null) return sniterateActNode;}
    throw new Error("Missing return statement in function");
}

  final public Node AndOrThreshExpression(boolean quantifier) throws ParseException, ParseException {Token rule;
  Token i;
  Token j;
  Node node = null;
  ArrayList<Node> nodes = new ArrayList<Node>();
    rule = jj_consume_token(ANDOR_THRESH);
    i = jj_consume_token(NUMBER);
    jj_consume_token(25);
    j = jj_consume_token(NUMBER);
    jj_consume_token(27);
    jj_consume_token(30);
    nodes = ExpressionList();
    jj_consume_token(26);
String ruleType = rule.image.trim().toLowerCase();
    ruleType = ruleType.substring(0, ruleType.length() - 1);
    try {
      if (ruleType.equals("andor")) {
        Relation min = network.getRelations().get("min");
        Relation max = network.getRelations().get("max");
        Node minNode = network.createNode(i.image.trim(), "individualnode");
        Node maxNode = network.createNode(j.image.trim(), "individualnode");
        DownCable minCable = new DownCable(min, new NodeSet(minNode));
        DownCable maxCable = new DownCable(max, new NodeSet(maxNode));

        Relation arg = network.getRelations().get("arg");
        HashMap<String, Node> objs = new HashMap<String, Node>();
        for (Node n : nodes)
          objs.put(n.getName(), n);

        NodeSet set = new NodeSet(objs);
        DownCable andorDCB = new DownCable(arg, set);
        HashMap<String, DownCable> sett = new HashMap<String, DownCable>();
        if (quantifier)
         {
          DownCable quant = new DownCable(network.getRelations().get("forall"), new NodeSet(varNodesForall));
          sett.put(quant.getRelation().getName(), quant);
        }
        sett.put(minCable.getRelation().getName(), minCable);
        sett.put(maxCable.getRelation().getName(), maxCable);
        sett.put(andorDCB.getRelation().getName(), andorDCB);

        DownCableSet dcs = new DownCableSet(sett);
        Node shouldCreate = compareMolecularNode(dcs);
        if (shouldCreate == null)
        node = network.createNode("andor", new DownCableSet(sett));
        else
        node = shouldCreate;

      } else {
        Relation threshMax = network.getRelations().get("threshmax");
        Relation thresh = network.getRelations().get("thresh");
        Node threshMaxNode = network.createNode(i.image.trim(), "propositionnode");
        Node threshNode = network.createNode(j.image.trim(), "propositionnode");
        DownCable threshMaxCable = new DownCable(threshMax, new NodeSet(threshMaxNode));
        DownCable threshCable = new DownCable(thresh, new NodeSet(threshNode));

        Relation arg = network.getRelations().get("arg");
        HashMap<String, Node> objs = new HashMap<String, Node>();
        for (Node n : nodes)
          objs.put(n.getName(), n);
        NodeSet set = new NodeSet(objs);
        DownCable threshDCB = new DownCable(arg, set);
        HashMap<String, DownCable> sett = new HashMap<String, DownCable>();
        if (quantifier)
         {
          DownCable quant = new DownCable(network.getRelations().get("forall"), new NodeSet(varNodesForall));
          sett.put(quant.getRelation().getName(), quant);
        }
        sett.put(threshMaxCable.getRelation().getName(), threshMaxCable);
        sett.put(threshCable.getRelation().getName(), threshCable);
        sett.put(threshDCB.getRelation().getName(), threshDCB);
        DownCableSet dcs = new DownCableSet(sett);
        Node shouldCreate = compareMolecularNode(dcs);
        if (shouldCreate == null)
        node = network.createNode("thresh", new DownCableSet(sett));
        else
        node = shouldCreate;
      }

    } catch (NoSuchTypeException e) {
      // TODO Auto-generated catch block
      e.printStackTrace();
    }
    {if ("" != null) return node;}
    throw new Error("Missing return statement in function");
}

  final public ArrayList<Node> ExpressionList() throws ParseException, ParseException {ArrayList<Node> nodes = new ArrayList<Node>();
  Node arg;
    arg = Expression();
nodes.add(arg);
    label_6:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case 25:{
        ;
        break;
        }
      default:
        jj_la1[9] = jj_gen;
        break label_6;
      }
      jj_consume_token(25);
      arg = Expression();
nodes.add(arg);
    }
{if ("" != null) return nodes;}
    throw new Error("Missing return statement in function");
}

  final public Node OrAndEntailment(boolean quantifier) throws ParseException, ParseException {ArrayList<Node> cq = new ArrayList<Node>();
ArrayList<Node> ant = new ArrayList<Node>();
Token ent;
    jj_consume_token(30);
    ant = ExpressionList();
    jj_consume_token(26);
    ent = jj_consume_token(ENTAILMENT);
    jj_consume_token(30);
    cq = ExpressionList();
    jj_consume_token(26);
HashMap<String, DownCable> sett = new HashMap<String,DownCable>();
  if(ent.image.trim().toLowerCase().equals("&=>"))
{
    Relation antecedent = network.getRelations().get("&ant");
    Relation consequent = network.getRelations().get("cq");
    HashMap<String, Node> antHash = new HashMap<String, Node>();
    HashMap<String, Node> cqHash = new HashMap<String, Node>();
    Node andEntailmentNode = null;
    for (Node a : ant)
      antHash.put(a.getName(), a);
    DownCable antDC = new DownCable(antecedent, new NodeSet(antHash));
    for (Node a : cq)
      cqHash.put(a.getName(), a);
    DownCable cqDC = new DownCable(consequent, new NodeSet(cqHash));
   if (quantifier)
         {
          DownCable quant = new DownCable(network.getRelations().get("forall"), new NodeSet(varNodesForall));
          sett.put(quant.getRelation().getName(), quant);
        }
      sett.put(antDC.getRelation().getName(), antDC);
      sett.put(cqDC.getRelation().getName(), cqDC);
      DownCableSet dcs = new DownCableSet(sett);
      Node shouldCreate = compareMolecularNode(dcs);
      try {
        if(shouldCreate==null)
        andEntailmentNode = network.createNode("andentailment", new DownCableSet(sett));
        else
        andEntailmentNode = shouldCreate;
      } catch (NoSuchTypeException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
      }

    {if ("" != null) return andEntailmentNode;}
}
else {
  if(ent.image.trim().toLowerCase().equals("&=>"))
{
    Relation antecedent = network.getRelations().get("ant");
    Relation consequent = network.getRelations().get("cq");
    HashMap<String, Node> antHash = new HashMap<String, Node>();
    HashMap<String, Node> cqHash = new HashMap<String, Node>();
    Node orEntailmentNode = null;
    for (Node a : ant)
      antHash.put(a.getName(), a);
    DownCable antDC = new DownCable(antecedent, new NodeSet(antHash));
    for (Node a : cq)
      cqHash.put(a.getName(), a);
    DownCable cqDC = new DownCable(consequent, new NodeSet(cqHash));
    if (quantifier)
         {
          DownCable quant = new DownCable(network.getRelations().get("forall"), new NodeSet(varNodesForall));
          sett.put(quant.getRelation().getName(), quant);
        }
      sett.put(antDC.getRelation().getName(), antDC);
      sett.put(cqDC.getRelation().getName(), cqDC);
        DownCableSet dcs = new DownCableSet(sett);
        Node shouldCreate = compareMolecularNode(dcs);
        try {
          if (shouldCreate == null)
            orEntailmentNode = network.createNode("orentailment", new DownCableSet(sett));
          else
            orEntailmentNode = shouldCreate;
        } catch (NoSuchTypeException e) {
          // TODO Auto-generated catch block
          e.printStackTrace();
        }

    {if ("" != null) return orEntailmentNode;}
} else
{
        String i = ent.image.trim().toLowerCase().charAt(0) + "";
        Relation antecedent = network.getRelations().get("&ant");
        Relation consequent = network.getRelations().get("cq");
        HashMap<String, Node> antHash = new HashMap<String, Node>();
        HashMap<String, Node> cqHash = new HashMap<String, Node>();
        Node iEntailmentNode = null;
        Node iNode = null;
        try {
          iNode = network.createNode(i, "individualNode");
          DownCable iDC = new DownCable(network.getRelations().get("i"), new NodeSet(iNode));
          for (Node a : ant)
            antHash.put(a.getName(), a);
          DownCable antDC = new DownCable(antecedent, new NodeSet(antHash));
          for (Node a : cq)
            cqHash.put(a.getName(), a);
          DownCable cqDC = new DownCable(consequent, new NodeSet(cqHash));

          if (quantifier)
         {
          DownCable quant = new DownCable(network.getRelations().get("forall"), new NodeSet(varNodesForall));
          sett.put(quant.getRelation().getName(), quant);
        }
            sett.put(antDC.getRelation().getName(), antDC);
            sett.put(cqDC.getRelation().getName(), cqDC);
            sett.put(iDC.getRelation().getName(), iDC);
          DownCableSet dcs = new DownCableSet(sett);
          Node shouldCreate = compareMolecularNode(dcs);
          if (shouldCreate == null)
            iEntailmentNode = network.createNode("numentailment", new DownCableSet(sett));
          else
            iEntailmentNode = shouldCreate;
        } catch (NoSuchTypeException e) {
          // TODO Auto-generated catch block
          e.printStackTrace();
        }
        {
          if ("" != null)
            {if ("" != null) return iEntailmentNode;}
        }

      }
}
    throw new Error("Missing return statement in function");
}

  final public Node negatedProp() throws ParseException {Node node = null;
    jj_consume_token(23);
    node = Expression();
Node negatedNode = null;
      try {
        negatedNode = node.createNegation(node);
      } catch (NoSuchTypeException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
      }
    {if ("" != null) return negatedNode;}
    throw new Error("Missing return statement in function");
}

  final public Node gradedProp() throws ParseException {Node node = null;
  String gradeValue;
    jj_consume_token(24);
    node = Expression();
    jj_consume_token(25);
    gradeValue = jj_consume_token(NUMBER).image;
    jj_consume_token(26);
gradeValue = gradeValue.trim();
    // Relations
    Relation grade = network.getRelations().get("grade");
    Relation prop = network.getRelations().get("prop");

    // nodes
    Node gradeNode = null;
    Node molecNode = null;
    try {
      gradeNode = network.createNode(gradeValue, "individualnode");
      // cables
      DownCable gradeDC = new DownCable(grade, new NodeSet(gradeNode));
      DownCable propDC = new DownCable(prop, new NodeSet(node));
      DownCableSet alldcs = new DownCableSet(gradeDC, propDC);
      Node shouldCreate = compareMolecularNode(alldcs);
      if (shouldCreate == null)
        molecNode = network.createNode("propositionnode", alldcs);
      else
        molecNode = shouldCreate;
    } catch (NoSuchTypeException e) {
      // TODO Auto-generated catch block
      e.printStackTrace();
    }

    {if ("" != null) return molecNode;}
    throw new Error("Missing return statement in function");
}

  final public Node Predicate() throws ParseException {Token num;
  Token predicateName;
    predicateName = jj_consume_token(PREDICATE_NAME_BRACKET);
    Arguments(predicateName.image.toLowerCase());
    jj_consume_token(27);
String pNodeName = predicateName.image.trim().toLowerCase();
    pNodeName = pNodeName.substring(0, pNodeName.length() - 1);
    Node pNode = null;
    Node molec = null;
    Relation rel = null ;
    try {
       pNode = network.createNode(pNodeName, "propositionnode");
       if(mode==1)
           rel = network.createRelation("r", "propositionnode", Adjustability.EXPAND, 2);
       if(mode == 2)
           rel = network.createRelation("rel" + pNodeName, "propositionnode", Adjustability.EXPAND, 2);
        if (rel == null && mode != 3) {
          {if (true) throw new ParseException("rel is null");}
      }
      if (mode != 3)
      {
      DownCable lastCable = new DownCable(rel, new NodeSet(pNode));
      allDCB.put(lastCable.getRelation().getName(), lastCable);
      }
      HashMap<String, DownCable> cloneAllDCB = new HashMap<String, DownCable>();
      for (DownCable x : allDCB.values())
        cloneAllDCB.put(x.getRelation().getName(), x);
      DownCableSet dcs = new DownCableSet(cloneAllDCB);
      Node shouldCreate = compareMolecularNode(dcs);
      if (shouldCreate == null)
        molec = network.createNode("propositionnode", dcs);
      else
        molec = shouldCreate;
      allDCB.clear();

    } catch (NoSuchTypeException e) {
      // TODO Auto-generated catch block
      e.printStackTrace();
    }
          {if ("" != null) return molec;}
    throw new Error("Missing return statement in function");
}

  final public void Arguments(String pName) throws ParseException {ArrayList<Node> leafNodes = new ArrayList<Node>();
  Node arg;
  pName = pName.substring(0, pName.length() - 1);
    arg = Argument();
leafNodes.add(arg);
    label_7:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case 25:{
        ;
        break;
        }
      default:
        jj_la1[10] = jj_gen;
        break label_7;
      }
      jj_consume_token(25);
      arg = Argument();
leafNodes.add(arg);
    }
if (mode == 3) {
      ArrayList<String> frame = null;
      for (ArrayList<String> s : caseFrames) {
        System.out.println(s.size() - 2);
        System.out.println(leafNodes.size());
        System.out.println(s.get(0).trim().toLowerCase());
        System.out.println(pName.trim().toLowerCase());
        for (String ss : s)
          System.out.println(ss);

        if ((s.size() - 2 == leafNodes.size()) && (pName.equals(s.get(0)))) {
          System.out.print(true);
          frame = s;
          break;
        }
      }
      if (frame == null)
          {if (true) throw new ParseException("No Such Case Frame");}

      Relation firstRel = null;
      if (frame.get(1) != "null") {
        firstRel = network.createRelation(frame.get(1), "propositionnode", Adjustability.EXPAND, 2);
        DownCable dcb = null;
        try {
          dcb = new DownCable(firstRel, new NodeSet(network.createNode(pName, "propositionnode")));
          allDCB.put(dcb.getRelation().getName(), dcb);

        } catch (NoSuchTypeException e) {
          // TODO Auto-generated catch block
          e.printStackTrace();
        }
      }
      for (int i = 0; i < leafNodes.size(); i++) {
        Relation r = network.createRelation(frame.get(i + 2), "propositionnode", Adjustability.EXPAND, 2);
        DownCable dcb = new DownCable(r, new NodeSet(leafNodes.get(i)));
        allDCB.put(dcb.getRelation().getName(), dcb);
      }

    } else {
      for (int i = 0; i < leafNodes.size(); i++) {
        Node variableN = leafNodes.get(i);
        Relation rel = null;
        if (mode == 1)
          rel = network.createRelation("a" + (i + 1), "propositionnode", Adjustability.EXPAND, 2);
        if (mode == 2)
          rel = network.createRelation("rel - arg#" + pName + (i + 1), "propositionnode", Adjustability.EXPAND, 2);
        if (rel == null)
          {if (true) throw new ParseException("rel is null");}
        DownCable dcb = new DownCable(rel, new NodeSet(variableN));
        allDCB.put(dcb.getRelation().getName(), dcb);
      }
    }
}

  final public Node Argument() throws ParseException {Token Argument;
Token var=null;
Network network = controller.getNetwork();
Node leafNode = null;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case STRING:{
      Argument = jj_consume_token(STRING);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case VARIABLE:{
        var = jj_consume_token(VARIABLE);
        break;
        }
      default:
        jj_la1[11] = jj_gen;
        ;
      }
String argString = Argument.image.trim().toLowerCase();
  System.out.println(argString);
        try {
          if (var != null)
            leafNode = network.createVariableNode(argString, "propositionnode");
          else
            leafNode = network.createNode(argString, "propositionnode");
        } catch (NoSuchTypeException e) {
          // TODO Auto-generated catch block
          e.printStackTrace();
        }
        {if ("" != null) return leafNode;}
      break;
      }
    case ANDOR_THRESH:
    case WHENDO_DOIF:
    case QUANTIFIER:
    case PREDICATE_NAME_BRACKET:
    case 23:
    case 24:
    case 30:{
      leafNode = Expression();
{if ("" != null) return leafNode;}
      break;
      }
    default:
      jj_la1[12] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
}

  final public void defineFrame() throws ParseException, ParseException {ArrayList<String> allRelationNames = new ArrayList<String>();
  String relName;
  Token predicateName;
    predicateName = jj_consume_token(PREDICATE_NAME_BRACKET);
    relName = relationName();
allRelationNames.add(relName);
    label_8:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case 25:{
        ;
        break;
        }
      default:
        jj_la1[13] = jj_gen;
        break label_8;
      }
      jj_consume_token(25);
      relName = relationName();
allRelationNames.add(relName);
    }
    jj_consume_token(27);
    jj_consume_token(0);
String predName = predicateName.image.trim().toLowerCase();
    predName = predName.substring(0, predName.length() - 1);
    removeDuplicates(allRelationNames);
    allRelationNames.add(0, predName);
    int index = indexOfList(caseFrames, allRelationNames);
    if (index != -1) {
      // If listToAdd already exists, remove it
      caseFrames.remove(index);
      System.out.println("Removed duplicate list from the list of lists.");
    }

    // Add listToAdd to listOfLists
    caseFrames.add(allRelationNames);
    ArrayList<String> s = caseFrames.getLast();
    System.out.print("Case frame " + s.get(0) + "(" + s.get(1));
    if (s.size() > 2) {
      for (int i = 2; i < s.size(); i++) {
        System.out.print(", " + s.get(i));
      }
    }
    System.out.println(")" + " has been created.");
}

  final public String relationName() throws ParseException, ParseException {Token s;
    s = jj_consume_token(STRING);
String relationName = s.image.trim().toLowerCase();
      {if ("" != null) return relationName;}
    throw new Error("Missing return statement in function");
}

  final public void Command() throws ParseException, ParseException {Token stringToken;
     Token t = null;
        Token wffNameList = null;
       Token attitudeSet = null;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case currContext:
    case GetAttitudeNames:
    case MODE1:
    case MODE2:
    case MODE3:
    case 84:{
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case currContext:{
        jj_consume_token(currContext);
try {
        String s = ContextController.getCurrContextName();
        System.out.println(s);
      } catch (Exception e) {
        System.out.println("No Current Context");
      }
        break;
        }
      case GetAttitudeNames:{
        jj_consume_token(GetAttitudeNames);
HashMap<String, Integer> attitudeNames = ContextController.getAttitudes().getSet();
            System.out.println("List of attitude names:");

          // Iterate over the attitude names and print them
        for (String key : attitudeNames.keySet()) {
          System.out.println(key);
        }
        break;
        }
      case MODE1:{
        jj_consume_token(MODE1);
mode = 1;
       System.out.println("Operating in mode 1 (Default)");
      System.out.println(mode);
        break;
        }
      case MODE2:{
        jj_consume_token(MODE2);
mode = 2;
      System.out.println("Operating in mode 2");
      System.out.println(mode);
        break;
        }
      case MODE3:{
        jj_consume_token(MODE3);
mode = 3;
      System.out.println("Operating in mode 3");
      System.out.println(mode);
        break;
        }
      case 84:{
        defineContext();
        break;
        }
      default:
        jj_la1[14] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
      }
    case 39:{
      jj_consume_token(39);
      defineFrame();
      break;
      }
    case 40:{
      jj_consume_token(40);
      defineSemantic();
      break;
      }
    case 41:{
Token CName;
      jj_consume_token(41);
      Bridge();
HashMap<String, HashMap<String, Node>> molecN = network.getMolecularNodes();
      for(HashMap<String, Node> x : molecN.values()){
       for(Node n : x.values()){
        System.out.println(n.toString());
       }

    }
      break;
      }
    case 57:{
      setCurrentContext();
      break;
      }
    case 56:{
      getAllContexts();
      break;
      }
    case 55:{
      forwardInference();
      break;
      }
    case 51:{
      AddToContext();
      break;
      }
    case 48:{
      RemoveFromContext();
      break;
      }
    case 47:{
      DescribeContext();
      break;
      }
    case 46:{
      getAllSupported();
      break;
      }
    case 45:{
      backInferSub();
      break;
      }
    case 44:{
      performAct();
      break;
      }
    case 42:{
      clearNetwork();
      break;
      }
    case 43:{
      clearInfer();
      break;
      }
    default:
      jj_la1[15] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
}

  final public void clearNetwork() throws ParseException, ParseException {
    jj_consume_token(42);
network.setBaseNodes(new HashMap<String,Node>());
    network.setNodes(new HashMap<Integer,Node>());
    network.setMolecularNodes(new HashMap<String,HashMap<String,Node>>());
    network.setRelations(new HashMap<String,Relation>());
    network.getPropositionNodes().clear();

    CLI.print("Network is Cleared.");
}

  final public void clearInfer() throws ParseException, ParseException {
    jj_consume_token(43);
String x;
}

  final public void performAct() throws ParseException, ParseException {Node node = null;
  ActNode actNode = null;
    jj_consume_token(44);
    node = Act();
actNode = (ActNode)node;

    try {
      actNode.perform();
    } catch (NoSuchTypeException e) {
      // TODO Auto-generated catch block
      CLI.print(e.getMessage());
    } catch (NoPlansExistForTheActException e) {
      // TODO Auto-generated catch block
      CLI.print(e.getMessage());
    } catch (DirectCycleException e) {
      // TODO Auto-generated catch block
      CLI.print(e.getMessage());
    }
}

  final public void backInferSub() throws ParseException, ParseException {
    jj_consume_token(45);
String x;
}

  final public void getAllSupported() throws ParseException, ParseException {
    jj_consume_token(46);
HashMap<Integer, ArrayList<String>> allWffs = wffs;
    if (allWffs != null) {
      for (ArrayList<String> list : allWffs.values()) {
        for (int i = 0; i < list.size(); i++) {
          if (i == 0)
            CLI.print(list.getFirst() + " is Supported in :");
          else
            CLI.print(list.get(i));
        }
      }
    } else
      CLI.print("No Hypothesis Supported in Any Context.");
}

  final public void DescribeContext() throws ParseException, ParseException {String CName=null;
    jj_consume_token(47);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case STRING:{
      CName = jj_consume_token(STRING).image;
      break;
      }
    default:
      jj_la1[16] = jj_gen;
      ;
    }
if (CName == null) {
      try{
      CName = controller.getCurrContextName();
      CName = CName.trim();
      }catch(Exception e){
        CLI.print("Set Default Context First.");
      }

    }
    else{
      CName = CName.trim();
      if(!controller.getContextSet().getSet().containsKey(CName.trim()))
        {if (true) throw new ParseException("Context Does Not Exist.");}
          CLI.print("Hypothesis in Context " + CName + ":");
    for (ArrayList<String> contexts : wffs.values()) {
      String wffName = contexts.get(0);
      for (int i = 1; i < contexts.size(); i++) {
        String cxt = contexts.get(i);
        String[] name_attitude = cxt.split("_");
        CLI.print(wffName + " supported in attitude " + name_attitude[1]);
      }

    }
    }
}

  final public void RemoveFromContext() throws ParseException, ParseException {String CName = null;
  String attitude;
  Node node = null;
    jj_consume_token(48);
    jj_consume_token(49);
    node = Expression();
    jj_consume_token(50);
    jj_consume_token(49);
    attitude = jj_consume_token(STRING).image;
    jj_consume_token(50);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case 49:{
      jj_consume_token(49);
      CName = jj_consume_token(STRING).image;
      jj_consume_token(50);
      break;
      }
    default:
      jj_la1[17] = jj_gen;
      ;
    }
try {

      Integer attNum = controller.getAttitudeNumber(attitude.trim());
    if (CName == null) {
      try{
      CName = controller.getCurrContextName();
      CName = CName.trim();
      }catch(Exception e){
        CLI.print("Set Default Context First.");
      }
    }
    else{
      CName = CName.trim();
      if(!controller.getContextSet().getSet().containsKey(CName.trim()))
        {if (true) throw new ParseException("Context Does Not Exist.");}
    }
      if (attNum != null) {
        controller.removeFromContext(CName, attNum, node.getId());
        if (wffs.containsKey(node.getId())) {
          ArrayList<String> contexts = wffs.get(node.getId());
          contexts.remove(CName + "_" + attNum);
          if (contexts.size() == 1)
            wffs.remove(node.getId());
          else
            wffs.put(node.getId(), contexts);
          CLI.print("Hypothesis Removed from Context " + CName + " in Attitude " + attitude.trim());
        } else
          CLI.print("Hypothesis Does Not Exist in " + CName + " in Attitude " + attitude.trim());
      } else
        CLI.print("No Such Attitude.");

    } catch (Exception e) {
      CLI.print(e.getMessage());
      // TODO: handle exception
    }
}

  final public void AddToContext() throws ParseException, ParseException {String attitude;
    String CName = null;
    Node nn;
    jj_consume_token(51);
    jj_consume_token(49);
    nn = Expression();
    jj_consume_token(50);
    jj_consume_token(49);
    attitude = jj_consume_token(STRING).image;
    jj_consume_token(50);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case 49:{
      jj_consume_token(49);
      CName = jj_consume_token(STRING).image;
      jj_consume_token(50);
      break;
      }
    default:
      jj_la1[18] = jj_gen;
      ;
    }
if (CName == null) {
        try{
        CName = controller.getCurrContextName();
        CName = CName.trim();
        }catch(Exception e){
          CLI.print("Set Default Context First.");
        }
    }
    else{
      CName = CName.trim();
      if(!controller.getContextSet().getSet().containsKey(CName.trim()))
        {if (true) throw new ParseException("Context Does Not Exist.");}
    }
    PropositionNode node = (PropositionNode) nn;
    Integer attNum = controller.getAttitudeNumber(attitude);
    CName = CName.trim().toLowerCase();
    if (attNum == null)
        {if (true) throw new ParseException("No Such Attitude.");}

    if (wffs.containsKey(node.getId())) {
      ArrayList<String> wffName = wffs.get(node.getId());
      for (int i = 1; i < wffName.size(); i++) {
        if (wffName.get(i).equals(CName + "_" + attNum)) {
          if (true) {
            if (true)
              {if (true) throw new ParseException("Already Supported in Context " + CName + " in attitude " + attitude);}
          }
        }
      }
    }

    try {
      CLI.print(node.toString()+" is supported in " + CName +" in attitude " + attitude+".");
      controller.addHypothesisToContext(CName, attNum, node);
      if (wffs.containsKey(node.getId())) {
        ArrayList<String> wffName = wffs.get(node.getId());
        wffName.addLast(CName + "_" + attNum);
        wffs.put(node.getId(), wffName);
    } else {
        ArrayList<String> list = new ArrayList<String>();
        list.add("wff_" + wffCount);
        wffCount++;
        list.add(CName + "_" + attNum);
        wffs.put(node.getId(), list);
    }
    } catch (Exception e) {
      // TODO Auto-generated catch block
      CLI.print(e.getMessage());

    }

    HashMap<String, HashMap<String, Node>> molecN = network.getMolecularNodes();
    for (HashMap<String, Node> x : molecN.values()) {
      for (Node n : x.values()) {
        System.out.println(n.toString());
      }
    }
}

  final public void backwardInferenceV1() throws ParseException, ParseException {Node node;
  String CName = null;
    jj_consume_token(52);
    jj_consume_token(STRING);
    jj_consume_token(26);
    jj_consume_token(53);
    jj_consume_token(STRING);
    jj_consume_token(26);
    Expression();
}

  final public void backwardInferenceV2() throws ParseException, ParseException {Node node;
  String CName = null;
    jj_consume_token(52);
    jj_consume_token(STRING);
    jj_consume_token(26);
    Expression();
}

  final public void backwardInferenceV3() throws ParseException, ParseException {Node node;
  String CName = null;
    jj_consume_token(53);
    jj_consume_token(STRING);
    jj_consume_token(26);
    Expression();
}

  final public void backwardInferenceV4() throws ParseException, ParseException {Node node;
  String CName = null;
    Expression();
}

  final public void backwardInference() throws ParseException, ParseException {
    jj_consume_token(54);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case 52:{
      backwardInferenceV1();
      break;
      }{
      backwardInferenceV2();
      break;
      }
    case 53:{
      backwardInferenceV3();
      break;
      }
    case ANDOR_THRESH:
    case WHENDO_DOIF:
    case QUANTIFIER:
    case PREDICATE_NAME_BRACKET:
    case 23:
    case 24:
    case 30:{
      backwardInferenceV4();
      break;
      }
    default:
      jj_la1[19] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
}

  final public void forwardInference() throws ParseException, ParseException {Node node;
  String CName = null;
    jj_consume_token(55);
    jj_consume_token(49);
    node = Expression();
    jj_consume_token(50);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case 49:{
      jj_consume_token(49);
      CName = jj_consume_token(STRING).image;
      jj_consume_token(50);
      break;
      }
    default:
      jj_la1[20] = jj_gen;
      ;
    }
PropositionNode prop = (PropositionNode) node;

    if (CName == null) {
      try {
        CName = controller.getCurrContextName();
        CName = CName.trim();
      } catch (Exception e) {
        CLI.print("Set Default Context First.");
      }

    } else {
      CName = CName.trim();
      if (!controller.getContextSet().getSet().containsKey(CName.trim())) {
        if (true)
          {if (true) throw new ParseException("Context Does Not Exist.");}
      }

    }
    try {
      String oldCurrContext = controller.getCurrContextName();
      controller.setCurrContext(CName);
      prop.add();
      controller.setCurrContext(oldCurrContext);
    } catch (NoSuchTypeException e) {
      // TODO Auto-generated catch block
      e.printStackTrace();
    } catch (NoPlansExistForTheActException e) {
      // TODO Auto-generated catch block
      e.printStackTrace();
    } catch (DirectCycleException e) {
      // TODO Auto-generated catch block
      e.printStackTrace();
    }
}

  final public void getAllContexts() throws ParseException, ParseException {
    jj_consume_token(56);
HashMap<String, Context> set = controller.getContextSet().getSet();
     System.out.println("All Contexts Defined:");
    for(String cName  : set.keySet()){
      System.out.println(cName);
    }
}

  final public void setCurrentContext() throws ParseException, ParseException {String cName;
    jj_consume_token(57);
    cName = jj_consume_token(STRING).image;
cName = cName.trim().toLowerCase();
    try {
      controller.setCurrContext(cName);
      CLI.print("Current Context is Set to " + cName);
    } catch (Exception e) {
      System.out.println(e.getMessage());
      // TODO: handle exception
    }
}

  final public void setCurrentAttitude() throws ParseException, ParseException {String attitude;
    jj_consume_token(58);
    attitude = jj_consume_token(STRING).image;
attitude = attitude.trim().toLowerCase();

    Integer num = controller.getAttitudeNumber(attitude);
    if(num == null)
    {
      CLI.print("no such attitude. The current default attitude is " + controller.getAttitudeName(defaultAttitude)+".");

    }
    else{
      defaultAttitude = num;
      CLI.print("The default attitude has been set to "+attitude+".");
    }
}

  final public Node Bridge() throws ParseException, ParseException {HashMap<Node, Integer> antec = new HashMap<Node, Integer>();
  HashMap<Node, Integer> conseq = new HashMap<Node, Integer>();
    jj_consume_token(30);
    antec = bridgeExpressionList();
    jj_consume_token(26);
    jj_consume_token(30);
    conseq = bridgeExpressionList();
    jj_consume_token(26);
HashMap<Integer, ArrayList<Node>> antecGroupedByAttitude = groupByValue(antec);
    HashMap<Integer, ArrayList<Node>> conseqGroupedByAttitude = groupByValue(conseq);
    HashMap<String, DownCable> allDCs = new HashMap<String,DownCable>();
    for(Integer n : antecGroupedByAttitude.keySet())
      System.out.println(n+" lol");
    for (Integer n : antecGroupedByAttitude.keySet()) {
      ArrayList<Node> nodes = antecGroupedByAttitude.get(n);
      Relation antRel = network.createRelation(n + "-ant", "propositionnode", Adjustability.EXPAND, 2);
      NodeSet set = new NodeSet();
      for (Node node : nodes)
        set.add(node);
      DownCable dc = new DownCable(antRel, set);
      allDCs.put(antRel.getName(), dc);
    }

    for (Integer n : conseqGroupedByAttitude.keySet()) {
      ArrayList<Node> nodes = conseqGroupedByAttitude.get(n);
      Relation conseqRel = network.createRelation(n + "-cq", "propositionnode", Adjustability.EXPAND, 2);
      NodeSet set = new NodeSet();
      for (Node node : nodes)
        set.add(node);
      DownCable dc = new DownCable(conseqRel, set);
      allDCs.put(conseqRel.getName(), dc);
    }
    Node bridgeNode = null;
    DownCableSet allDBs = new DownCableSet(allDCs);
    try {
      Node shouldCreate = compareMolecularNode(allDBs);
      if (shouldCreate == null)
        bridgeNode = network.createNode("bridgerule", allDBs);
      else
        bridgeNode = shouldCreate;
    } catch (NoSuchTypeException e) {
      // TODO Auto-generated catch block
      e.printStackTrace();
    }
    {if ("" != null) return bridgeNode;}
    throw new Error("Missing return statement in function");
}

  final public HashMap<Node, Integer> bridgeExpressionList() throws ParseException {ArrayList<Node> nodes = new ArrayList<Node>();
  Node arg;
  ArrayList<String> attitudes = new ArrayList<String>();
  String attitude;
    jj_consume_token(30);
    arg = Expression();
    jj_consume_token(25);
    attitude = jj_consume_token(STRING).image;
    jj_consume_token(26);
nodes.add(arg); attitudes.add(attitude.trim().toLowerCase());
    label_9:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case 25:{
        ;
        break;
        }
      default:
        jj_la1[21] = jj_gen;
        break label_9;
      }
      jj_consume_token(25);
      jj_consume_token(30);
      arg = Expression();
      jj_consume_token(25);
      attitude = jj_consume_token(STRING).image;
      jj_consume_token(26);
nodes.add(arg); attitudes.add(attitude.trim().toLowerCase());
    }
ArrayList<Integer> attitudeNo = new ArrayList<Integer>();
   for(String s  : attitudes) {
    Integer num = controller.getAttitudeNumber(s);
    if(num==null)
      {if (true) throw new ParseException("No such attitude");}
    attitudeNo.add(num);
   }
    HashMap<Node, Integer> node_attitude = new HashMap<Node, Integer>();
    for(int i = 0; i<nodes.size();i++){
      node_attitude.put(nodes.get(i),attitudeNo.get(i));
    }
    {if ("" != null) return node_attitude;}
    throw new Error("Missing return statement in function");
}

  final public void defineSemantic() throws ParseException, ParseException {String typeName;
  String superClass = null;
    jj_consume_token(49);
    typeName = jj_consume_token(STRING).image;
    jj_consume_token(50);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case 49:{
      jj_consume_token(49);
      superClass = jj_consume_token(STRING).image;
      jj_consume_token(50);
      break;
      }
    default:
      jj_la1[22] = jj_gen;
      ;
    }
typeName = typeName.trim();
    superClass = superClass.trim();

    if (network.getUserDefinedClasses().containsKey(typeName)) {
      if (true)
        {if (true) throw new ParseException("User Defined Class with the Same Name Already Exists.");}
    }

    while (true) {
      CLI.print("Create Custom Methods to Create Your Custom Class Using Command 'custom-method' ");
      String s = CLI.readInput();
      if (s.trim().toLowerCase().equals("done")){
        try {
          network.createNewSemanticType(typeName, superClass, customMethods);
        } catch (Exception e) {
          // TODO Auto-generated catch block
          e.printStackTrace();
        }
        break;
      }
      MindGRAF_Parser parser = new MindGRAF_Parser(
          new StringReader(s));
      try {
        parser.customMethod();
      } catch (ParseException e) {
        System.out.println();
        System.out.println(e.getMessage());

        // TODO Auto-generated catch block

        continue;
      }
    }
}

  final public void customMethod() throws ParseException, ParseException {String methodName = null;
  String returnType  = null;
  ArrayList<String> params = new ArrayList<String>();
  ArrayList<String> args = new ArrayList<String>();
  String methodCode = null;
    jj_consume_token(59);
    jj_consume_token(49);
    methodName = jj_consume_token(STRING).image;
    jj_consume_token(50);
    jj_consume_token(49);
    params = methodParams();
    jj_consume_token(50);
    jj_consume_token(49);
    args = methodArgs();
    jj_consume_token(50);
    jj_consume_token(49);
    returnType = jj_consume_token(STRING).image;
    jj_consume_token(50);
    methodCode = methodCode();
methodName = methodName.trim();
    returnType = returnType.trim();

    if (args.size() != params.size())
      {if (true) throw new ParseException("args != params");}
    ArrayList<Class<?>> methodParams = new ArrayList<Class<?>>();
    CustomMethod customMethod = null;
    try {
      for (int i = 0; i < params.size(); i++)
        methodParams.add(Class.forName(params.get(i)));
      customMethod = new CustomMethod(methodName, methodCode, Class.forName(returnType), methodParams,
          args);
          customMethods.add(customMethod);
    } catch (ClassNotFoundException e) {
      // TODO: handle exception
    }
}

  final public String methodCode() throws ParseException, ParseException {StringBuilder methodCodeBuilder = new StringBuilder();
    label_10:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case STRING:{
        jj_consume_token(STRING);
        break;
        }
      case 60:{
        jj_consume_token(60);
        break;
        }
      case 25:{
        jj_consume_token(25);
        break;
        }
      case 61:{
        jj_consume_token(61);
        break;
        }
      case 62:{
        jj_consume_token(62);
        break;
        }
      case 28:{
        jj_consume_token(28);
        break;
        }
      case 27:{
        jj_consume_token(27);
        break;
        }
      case 49:{
        jj_consume_token(49);
        break;
        }
      case 50:{
        jj_consume_token(50);
        break;
        }
      case 30:{
        jj_consume_token(30);
        break;
        }
      case 26:{
        jj_consume_token(26);
        break;
        }
      case 63:{
        jj_consume_token(63);
        break;
        }
      case 64:{
        jj_consume_token(64);
        break;
        }
      case 65:{
        jj_consume_token(65);
        break;
        }
      case 66:{
        jj_consume_token(66);
        break;
        }
      case 67:{
        jj_consume_token(67);
        break;
        }
      case 68:{
        jj_consume_token(68);
        break;
        }
      case 69:{
        jj_consume_token(69);
        break;
        }
      case 70:{
        jj_consume_token(70);
        break;
        }
      case 71:{
        jj_consume_token(71);
        break;
        }
      case 72:{
        jj_consume_token(72);
        break;
        }
      case 73:{
        jj_consume_token(73);
        break;
        }
      case 74:{
        jj_consume_token(74);
        break;
        }
      case 75:{
        jj_consume_token(75);
        break;
        }
      case 76:{
        jj_consume_token(76);
        break;
        }
      case VARIABLE:{
        jj_consume_token(VARIABLE);
        break;
        }
      case 77:{
        jj_consume_token(77);
        break;
        }
      case 78:{
        jj_consume_token(78);
        break;
        }
      case 79:{
        jj_consume_token(79);
        break;
        }
      case 80:{
        jj_consume_token(80);
        break;
        }
      case 23:{
        jj_consume_token(23);
        break;
        }
      case NUMBER:{
        jj_consume_token(NUMBER);
        break;
        }
      default:
        jj_la1[23] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case NUMBER:
      case VARIABLE:
      case STRING:
      case 23:
      case 25:
      case 26:
      case 27:
      case 28:
      case 30:
      case 49:
      case 50:
      case 60:
      case 61:
      case 62:
      case 63:
      case 64:
      case 65:
      case 66:
      case 67:
      case 68:
      case 69:
      case 70:
      case 71:
      case 72:
      case 73:
      case 74:
      case 75:
      case 76:
      case 77:
      case 78:
      case 79:
      case 80:{
        ;
        break;
        }
      default:
        jj_la1[24] = jj_gen;
        break label_10;
      }
    }
methodCodeBuilder.append(token.image);
    {if ("" != null) return methodCodeBuilder.toString();}
    throw new Error("Missing return statement in function");
}

  final public ArrayList<String> methodArgs() throws ParseException, ParseException {ArrayList<String> allArgs = new ArrayList<String>();
  String arg;
    arg = methodArg();
allArgs.add(arg);
    label_11:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case 25:{
        ;
        break;
        }
      default:
        jj_la1[25] = jj_gen;
        break label_11;
      }
      jj_consume_token(25);
      arg = methodArg();
allArgs.add(arg);
    }
{if ("" != null) return allArgs;}
    throw new Error("Missing return statement in function");
}

  final public String methodArg() throws ParseException, ParseException {Token arg = null;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case STRING:{
      arg = jj_consume_token(STRING);
      break;
      }
    case NUMBER:{
      arg = jj_consume_token(NUMBER);
      break;
      }
    default:
      jj_la1[26] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
String a = arg.image.trim();
    {if ("" != null) return a;}
{if (true) throw new ParseException("Invalid argument");}
    throw new Error("Missing return statement in function");
}

  final public ArrayList<String> methodParams() throws ParseException, ParseException {ArrayList<String> allParams = new ArrayList<String>();
  String arg;
    arg = methodParam();
allParams.add(arg);
    label_12:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case 25:{
        ;
        break;
        }
      default:
        jj_la1[27] = jj_gen;
        break label_12;
      }
      jj_consume_token(25);
      arg = methodParam();
allParams.add(arg);
    }
{if ("" != null) return allParams;}
    throw new Error("Missing return statement in function");
}

  final public String methodParam() throws ParseException, ParseException {Token param;
    param = jj_consume_token(STRING);
String p = param.image.trim();
    {if ("" != null) return p;}
    throw new Error("Missing return statement in function");
}

  final public void UVBR() throws ParseException, ParseException {Token value;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case 81:{
      jj_consume_token(81);
uvbrEnabled=true;
      System.out.println("UVBR is ON");
      Set attitudeNames = new Set();
      attitudeNames.setSet(initialAttitudes);
      controller.setUp(attitudeNames,consisAttitudeLists,uvbrEnabled);

      //System.out.print("uvbr: "+controller.isUvbrEnabled());
      System.out.println("consis attitudes:" );
      for(ArrayList<Integer> i : controller.getConsistentAttitudes())
     {
      System.out.println("SET " + i+1);
      for( Integer x : i)
        System.out.print(x+" ");}
         System.out.print("attitudeNumbers");
      for(String key : controller.getAttitudes().getSet().keySet())
        System.out.println(key+": " +controller.getAttitudeNumber(key));
      break;
      }
    case 82:{
      jj_consume_token(82);
uvbrEnabled=false;
      System.out.println("UVBR is OFF");
            Set attitudeNames = new Set();
      attitudeNames.setSet(initialAttitudes);
      controller.setUp(attitudeNames,consisAttitudeLists,uvbrEnabled);

      //System.out.print("uvbr: "+controller.isUvbrEnabled());
      System.out.println("consis attitudes:" );
      for(ArrayList<Integer> i : controller.getConsistentAttitudes())
     {
      System.out.println("SET " + i+1);
      for( Integer x : i)
        System.out.print(x+" ");}
         System.out.print("attitudeNumbers");
      for(String key : controller.getAttitudes().getSet().keySet())
        System.out.println(key+": " +controller.getAttitudeNumber(key));
      break;
      }
    default:
      jj_la1[28] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
}

  final public void setAttitudes() throws ParseException, ParseException {initialAttitudes.put("belief",0);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case 83:{
      jj_consume_token(83);
      jj_consume_token(30);
      attitude();
      label_13:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 25:{
          ;
          break;
          }
        default:
          jj_la1[29] = jj_gen;
          break label_13;
        }
        jj_consume_token(25);
        attitude();
      }
      jj_consume_token(26);
System.out.println("Attitudes Defined:");
    for(String key : initialAttitudes.keySet()){
    System.out.println(key);
   }
      break;
      }
    case N:{
      jj_consume_token(N);
      break;
      }
    default:
      jj_la1[30] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
}

  final public void defineContext() throws ParseException, ParseException {String CName;
    jj_consume_token(84);
    jj_consume_token(49);
    CName = jj_consume_token(STRING).image;
    jj_consume_token(50);
CName = CName.trim().toLowerCase();
    try{
    controller.createNewContext(CName);
    CLI.print("Context "+ CName +" is Created.");

    }catch(Exception e)
    {
      CLI.print(e.getMessage());
    }
}

  final public void wffAttitudeSet() throws ParseException, ParseException {
    jj_consume_token(30);
    jj_consume_token(WFF_NAME);
    jj_consume_token(25);
    jj_consume_token(STRING);
    jj_consume_token(26);
}

  final public void attitude() throws ParseException, ParseException {Token attitude;
    attitude = jj_consume_token(STRING);
String a = attitude.image.trim().toLowerCase();
if(initialAttitudes.containsKey(a))
{if (true) throw new ParseException("duplicate attitudes");}
initialAttitudes.put(a,attitudeNumber);
attitudeNumber++;
}

  final public void TelescopableAttitudes() throws ParseException, ParseException {ArrayList<Integer> list = new ArrayList<Integer>();
    jj_consume_token(85);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case 30:{
      list = telescopableAttitudeList();
      break;
      }
    default:
      jj_la1[31] = jj_gen;
      ;
    }
finalTelList = list;
    for (Integer in : list) {
                System.out.print(in + " ");
            System.out.println(); // Move to the next line after printing each inner list
        }
}

  final public ArrayList<Integer> telescopableAttitudeList() throws ParseException, ParseException {Token attitude;
  ArrayList<Integer> telList = new ArrayList<Integer>();
  Integer att ;
    jj_consume_token(30);
    att = OneAttitudeInList();
telList.add(att);
    label_14:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case 25:{
        ;
        break;
        }
      default:
        jj_la1[32] = jj_gen;
        break label_14;
      }
      jj_consume_token(25);
      att = OneAttitudeInList();
telList.add(att);
    }
    jj_consume_token(26);
{if ("" != null) return telList;}
    throw new Error("Missing return statement in function");
}

  final public Integer OneAttitudeInList() throws ParseException, ParseException {Token attitude;
    attitude = jj_consume_token(STRING);
String s = attitude.image.trim().toLowerCase();
  if(!initialAttitudes.containsKey(s))
    {if (true) throw new ParseException("Not in initially Defined Attitudes");}

  {if ("" != null) return initialAttitudes.get(s);}
    throw new Error("Missing return statement in function");
}

  final public void underConsequenceAttitudes() throws ParseException, ParseException {ArrayList<Integer> list = new ArrayList<Integer>();
    jj_consume_token(86);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case 30:{
      list = consequenceAttitudeList();
      break;
      }
    default:
      jj_la1[33] = jj_gen;
      ;
    }
finalConseqList = list;
    for (Integer in : list) {
                System.out.print(in + " ");
            System.out.println(); // Move to the next line after printing each inner list
        }
}

  final public ArrayList<Integer> consequenceAttitudeList() throws ParseException, ParseException {Token attitude;
  ArrayList<Integer> conseqList = new ArrayList<Integer>();
  Integer att ;
    jj_consume_token(30);
    att = OneAttitudeInList();
conseqList.add(att);
    label_15:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case 25:{
        ;
        break;
        }
      default:
        jj_la1[34] = jj_gen;
        break label_15;
      }
      jj_consume_token(25);
      att = OneAttitudeInList();
conseqList.add(att);
    }
    jj_consume_token(26);
{if ("" != null) return conseqList;}
    throw new Error("Missing return statement in function");
}

  final public void underConjunctionAttitudes() throws ParseException, ParseException {ArrayList<Integer> list = new ArrayList<Integer>();
    jj_consume_token(87);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case 30:{
      list = conjunctionAttitudeList();
      break;
      }
    default:
      jj_la1[35] = jj_gen;
      ;
    }
finalConjList = list;
    for (Integer in : list) {
                System.out.print(in + " ");
            System.out.println(); // Move to the next line after printing each inner list
        }
}

  final public ArrayList<Integer> conjunctionAttitudeList() throws ParseException, ParseException {Token attitude;
  ArrayList<Integer> conjList = new ArrayList<Integer>();
  Integer att ;
    jj_consume_token(30);
    att = OneAttitudeInList();
conjList.add(att);
    label_16:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case 25:{
        ;
        break;
        }
      default:
        jj_la1[36] = jj_gen;
        break label_16;
      }
      jj_consume_token(25);
      att = OneAttitudeInList();
conjList.add(att);
    }
    jj_consume_token(26);
{if ("" != null) return conjList;}
    throw new Error("Missing return statement in function");
}

  final public void consistentAttitudes() throws ParseException, ParseException {
    jj_consume_token(88);
    label_17:
    while (true) {
      consisAttitudeList();
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case 30:{
        ;
        break;
        }
      default:
        jj_la1[37] = jj_gen;
        break label_17;
      }
    }
for (ArrayList<Integer> list : consisAttitudeLists) {
            for (Integer num : list) {
                System.out.print(num + " ");
            }
            System.out.println(); // Move to the next line after printing each inner list
        }
}

  final public void consisAttitudeList() throws ParseException, ParseException {Token attitude;
    jj_consume_token(30);
    OneAttitudeInConsisList();
    label_18:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case 25:{
        ;
        break;
        }
      default:
        jj_la1[38] = jj_gen;
        break label_18;
      }
      jj_consume_token(25);
      OneAttitudeInConsisList();
    }
    jj_consume_token(26);
ArrayList<Integer> finalConsisList = new ArrayList<Integer>();
  for(int i = 0;i<consisAttitudeList.size();i++){
    finalConsisList.add(consisAttitudeList.get(i));
  }

consisAttitudeLists.add(finalConsisList);
consisAttitudeList.clear();

  System.out.println("now printing all contents:");

    for (ArrayList<Integer> list : consisAttitudeLists) {
            for (Integer num : list) {
                System.out.print(num + " ");
            }
            System.out.println(); // Move to the next line after printing each inner list
        }
System.out.print(consisAttitudeList.size()+" the size..");
System.out.println(consisAttitudeList.size()+" the size..");
System.out.println(finalConsisList.size()+" the size of the final list");
}

  final public void OneAttitudeInConsisList() throws ParseException, ParseException {Token attitude;
    attitude = jj_consume_token(STRING);
String s = attitude.image.trim().toLowerCase();
  if(!initialAttitudes.containsKey(s))
    {if (true) throw new ParseException("Not in initially Defined Attitudes");}
  currConsisAttitude = initialAttitudes.get(s);
  consisAttitudeList.add(currConsisAttitude);
}

  /** Generated Token Manager. */
  public MindGRAF_ParserTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[39];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static {
	   jj_la1_init_0();
	   jj_la1_init_1();
	   jj_la1_init_2();
	}
	private static void jj_la1_init_0() {
	   jj_la1_0 = new int[] {0x41c38000,0x40008000,0x41808000,0x2000000,0x80000000,0x2000000,0x2000000,0x2000000,0x2000000,0x2000000,0x2000000,0x80000,0x41e38000,0x2000000,0x7c0,0x7c0,0x200000,0x0,0x0,0x41c38000,0x0,0x2000000,0x0,0x5ea80020,0x5ea80020,0x2000000,0x200020,0x2000000,0x0,0x2000000,0x800,0x40000000,0x2000000,0x40000000,0x2000000,0x40000000,0x2000000,0x40000000,0x2000000,};
	}
	private static void jj_la1_init_1() {
	   jj_la1_1 = new int[] {0x0,0x0,0x0,0x0,0x7f,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x389ff80,0x0,0x20000,0x20000,0x300000,0x20000,0x0,0x20000,0xf0060000,0xf0060000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
	}
	private static void jj_la1_init_2() {
	   jj_la1_2 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x100000,0x100000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1ffff,0x1ffff,0x0,0x0,0x0,0x60000,0x0,0x80000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
	}

  /** Constructor with InputStream. */
  public MindGRAF_Parser(java.io.InputStream stream) {
	  this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public MindGRAF_Parser(java.io.InputStream stream, String encoding) {
	 try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
	 token_source = new MindGRAF_ParserTokenManager(jj_input_stream);
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 39; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
	  ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
	 try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
	 token_source.ReInit(jj_input_stream);
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 39; i++) jj_la1[i] = -1;
  }

  /** Constructor. */
  public MindGRAF_Parser(java.io.Reader stream) {
	 jj_input_stream = new SimpleCharStream(stream, 1, 1);
	 token_source = new MindGRAF_ParserTokenManager(jj_input_stream);
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 39; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
	if (jj_input_stream == null) {
	   jj_input_stream = new SimpleCharStream(stream, 1, 1);
	} else {
	   jj_input_stream.ReInit(stream, 1, 1);
	}
	if (token_source == null) {
 token_source = new MindGRAF_ParserTokenManager(jj_input_stream);
	}

	 token_source.ReInit(jj_input_stream);
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 39; i++) jj_la1[i] = -1;
  }

  /** Constructor with generated Token Manager. */
  public MindGRAF_Parser(MindGRAF_ParserTokenManager tm) {
	 token_source = tm;
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 39; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(MindGRAF_ParserTokenManager tm) {
	 token_source = tm;
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 39; i++) jj_la1[i] = -1;
  }

  private Token jj_consume_token(int kind) throws ParseException {
	 Token oldToken;
	 if ((oldToken = token).next != null) token = token.next;
	 else token = token.next = token_source.getNextToken();
	 jj_ntk = -1;
	 if (token.kind == kind) {
	   jj_gen++;
	   return token;
	 }
	 token = oldToken;
	 jj_kind = kind;
	 throw generateParseException();
  }


/** Get the next Token. */
  final public Token getNextToken() {
	 if (token.next != null) token = token.next;
	 else token = token.next = token_source.getNextToken();
	 jj_ntk = -1;
	 jj_gen++;
	 return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
	 Token t = token;
	 for (int i = 0; i < index; i++) {
	   if (t.next != null) t = t.next;
	   else t = t.next = token_source.getNextToken();
	 }
	 return t;
  }

  private int jj_ntk_f() {
	 if ((jj_nt=token.next) == null)
	   return (jj_ntk = (token.next=token_source.getNextToken()).kind);
	 else
	   return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;

  /** Generate ParseException. */
  public ParseException generateParseException() {
	 jj_expentries.clear();
	 boolean[] la1tokens = new boolean[89];
	 if (jj_kind >= 0) {
	   la1tokens[jj_kind] = true;
	   jj_kind = -1;
	 }
	 for (int i = 0; i < 39; i++) {
	   if (jj_la1[i] == jj_gen) {
		 for (int j = 0; j < 32; j++) {
		   if ((jj_la1_0[i] & (1<<j)) != 0) {
			 la1tokens[j] = true;
		   }
		   if ((jj_la1_1[i] & (1<<j)) != 0) {
			 la1tokens[32+j] = true;
		   }
		   if ((jj_la1_2[i] & (1<<j)) != 0) {
			 la1tokens[64+j] = true;
		   }
		 }
	   }
	 }
	 for (int i = 0; i < 89; i++) {
	   if (la1tokens[i]) {
		 jj_expentry = new int[1];
		 jj_expentry[0] = i;
		 jj_expentries.add(jj_expentry);
	   }
	 }
	 int[][] exptokseq = new int[jj_expentries.size()][];
	 for (int i = 0; i < jj_expentries.size(); i++) {
	   exptokseq[i] = jj_expentries.get(i);
	 }
	 return new ParseException(token, exptokseq, tokenImage);
  }

  private boolean trace_enabled;

/** Trace enabled. */
  final public boolean trace_enabled() {
	 return trace_enabled;
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

}
